['The Lens Protocol is a Web3 social graph on the Polygon Proof-of-Stake blockchain. It is designed to empower creators to own the links between themselves and their community, forming a fully composable, user-owned social graph. The protocol is built from the ground up with modularity in mind, allowing new features and fixes to be added while ensuring immutable user-owned content and social relationships.']
['Lens Protocol seeks to solve major issues in existing social media networks. Namely, Web2 networks all read from their unique, centralized database. There is no portability. Your profile, friends, and content are locked to a specific network and owned by the network operator. This causes each network to fight a zero-sum game for your attention. ']
["Lens Protocol corrects this by being a user-owned, open social graph that any application can plug into. Since users own their data, they can bring it to any application built on top of Lens Protocol. As the true owners of their content, creators no longer need to worry about losing their content, audience, and livelihood based on the whims of an individual platform's algorithms and policies. Additionally, each application using Lens Protocol benefits the whole ecosystem, turning the zero-sum game into a collaborative one. Developers can design meaningful social experiences without needing to turn to feedback mechanisms to lock in a user's attention."]
['Updated', ' ', '11 months ago', ' ']
['Comments allow users to provide additional commentary on other publications. They are treated the same as base ', 'Publications', " with extra checks and features. Like publications, comments live in the user's ", 'Profile NFT', ' and therefore are wholly owned by the user.']
["Since comments reference other publications, they are subject to the original publication's Reference Module conditions. If a publication has a reference module that limits comments only to accounts who ", 'follow', ' the original poster, and the commenter does not hold a Follow NFT, the transaction to comment will fail.']
["Just like regular publications, comments also have Collect and Reference Modules. Collect modules define how a comment can be minted into an NFT that references the comment's ContentURI. The Reference module contains logic that determines who can comment or mirror the new comment."]
['Get set up and hit the ground running in a matter of minutes!']
["To set things up, we're going first to clone the ", 'repository,', ' set up the environment, and finally, build and enter our Docker container!']
["As mentioned previously, you'll need Git and Docker Compose."]
['(Note: It can be blank for local development!)']
['Updated', ' ', '11 months ago', ' ']
['The purpose of the Lens Protocol is to empower creators to own the links between themselves and their community, forming a fully composable, decentralized social graph. This is achieved by allowing users to create profiles and interact with each other via these profiles. "Profile" (as used here) refers specifically to Lens profiles; "user" refers to standard crypto-wallets.']
['Note:', ' This is only tested on Unix-based systems, Docker facilitates development, but users can still opt not to use it. Windows users, if running into trouble, can consider setting up the ', 'WSL', '.']
["Alright, next up, we're going to spin up our own local blockchain and deploy the entire protocol on it."]
['Open up an ', 'additional terminal', ' and execute the following command:']
['To clean up leftover running containers, just execute the following command:']
['Updated', ' ', '4 months ago', ' ']
['The Profile NFT is the main object in the Lens Protocol. It is ownership over this NFT that gives you control of your content. Individual addresses own ProfileNFTs, and an address can contain multiple ProfileNFTs. What differentiates the Lens Profile NFT from other on-chain identities is the ability to post ', 'Publications', ' to it. The Profile NFT contains the history of all of the posts, ', 'mirrors', ', ', 'comments', ', and other content you generate.']
['Additionally, Profile NFTs contain a ', 'FollowModule', '. This module contains the logic that allows different accounts to be issued Follow NFTs to record their relationship to the main profile on-chain.']
['Profiles can only be minted by addresses that have been whitelisted by governance. This ensures that, given the low-fee environment present on Polygon, the namespace is not reserved by squatters. If you are building an application on Lens that requires the minting of Profiles, please join the ', 'Discord', ' and get in touch!']
['Updated', ' ', '8 months ago', ' ']
[]
['Publications are the lifeblood of the Lens Protocol. They are all of the original content, comments, and mirrors produced by creators, curators, and users alike. Publications come in three primary types: posts, comments, and mirrors. Posts are the base object, with mirror and comment providing additional functionality. To learn more about ', 'Mirrors', ' and ', 'Comments', ' please go to their respective documentation pages.']
["Publications are posted directly to a user's ", 'ProfileNFTs', '; this ensures that all content created by a user remains user-owned and in their wallet. Publications are ', 'NOT', " NFT's."]
['Publications have a ContentURI which points to the specific content the publication contains, this can point to text, an image, a video, or other arbitrary content stored on either a decentralized protocol such as ', 'IPFS', ' or ', 'Arweave', ', or a centralized storage provider like AWS S3.']
['Publications also have two attached modules, a Collect Module, and a Reference Module. The ', 'Collect Module', " contains the logic that allows other users to mint your publication into an NFT. This NFT will reference the original Publication's URI. The Reference Module controls references to the publication itself. It contains the logic that determines who can ", 'comment', ' and ', 'mirror', ' the publication.']
['Updated', ' ', '3 months ago', ' ']
['Unpause the protocol with your custom Hardhat task!']
["The repository's ", 'hardhat.config.ts', ' is set up to import all tasks in the ', 'tasks/', " directory, which means all we've got to do to start interacting with our local deployment is create a new task."]
['Create a file ', 'unpause.ts', ' in the ', 'tasks/', " directory and open it up in your editor of choice. The first thing you'll want to do is import some modules. "]
["Since we're working with hardhat tasks, we can use the instance of ", 'ethers', " injected into the Hardhat runtime environment, we won't be needing to import it in this specific task, but it's used behind the scenes. We'll also be using ", 'typechain', ', which creates convenient typescript bindings that we can connect to our deployed contracts.']
["Below are all the imports we'll need to set the protocol state (i.e., Unpause it); we'll explain how we use each one down the line."]
['Lens Protocol evolves and thrives on the contributions of its community. Feedback on improving the Lens Ecosystem is collected and presented in the Inspiration for Builders below.']
['CHECK OUT THE #', 'LENSVERSE']
['Updated', ' ', '2 months ago', ' ']
['The Lens Protocol is a Web3 social graph on the Polygon Proof-of-Stake blockchain. It is designed to empower creators to own the links between themselves and their community, forming a fully composable, user-owned social graph. The protocol is built from the ground up with modularity in mind, allowing new features and fixes to be added while ensuring immutable user-owned content and social relationships.']
['Lens Protocol seeks to solve major issues in existing social media networks. Namely, Web2 networks all read from their unique, centralized database. There is no portability. Your profile, friends, and content are locked to a specific network and owned by the network operator. This causes each network to fight a zero-sum game for your attention. ']
["Lens Protocol corrects this by being a user-owned, open social graph that any application can plug into. Since users own their data, they can bring it to any application built on top of Lens Protocol. As the true owners of their content, creators no longer need to worry about losing their content, audience, and livelihood based on the whims of an individual platform's algorithms and policies. Additionally, each application using Lens Protocol benefits the whole ecosystem, turning the zero-sum game into a collaborative one. Developers can design meaningful social experiences without needing to turn to feedback mechanisms to lock in a user's attention."]
['Updated', ' ', '11 months ago', ' ']
['The protocol is built from the ground up with modularity in mind. Lens Protocol is currently overseen by a multisig, which will be expanded to a broader DAO, which can develop and vote on new modules and expanded functionality.']
["Let's first dig into profile creation and publishing. Users must create a profile on the hub, for which they will receive a sequentially ID'd profile NFT. This NFT controls the profile, and thus, its owner becomes the de facto controller of the given profile."]
['Profile owners can:']
['Regular wallets can:']
['The Lens protocol has three layers of tokenization via ERC721 NFTs. All three are ERC721-compliant and fully composable.']
['The ', 'LensHub', ' upgradeable contract is the core entry point for the majority of interactions in the Lens Protocol. Nearly all interactions begin and doubles as the ERC721 NFT contract for profile NFTs, which are minted upon profile creation.']
["Upon a profile's first follow, a ", 'FollowNFT', ' contract is deployed (via minimal proxy cloning), unique to the profile; this is the ERC721 NFT contract that represents follower positions.']
["Lastly, upon a publication's first collect, a ", 'CollectNFT', ' contract is deployed (again, via minimal proxy cloning), unique to the publication; this is the ERC721 NFT contract that represents collected publications.']
['Note that follow and collect NFTs are deployed only upon the first follow/collect, respectively. This reduces gas overhead for profile creation.']
['A quick summary as to what to expect from this guide.']
["Next, we've got to create the hardhat task (which will automatically be imported in our Hardhat config file if this ", 'custom', " file exists). Our actual code to be executed will be a callback function in the tasks' ", 'setAction', ' property.']
["Alright, so we've created our Hardhat task. Now we've got to instantiate our signers (a wallet that can sign and send transactions) and begin interacting with the protocol! Our local deployment uses the default signers connected to the injected ", 'ethers', ' instance and automatically maps them to different protocol roles. ']
["For our purposes, the 0-indexed account is the deployer, the 1-indexed account is the governance address, the 2-indexed account is the treasury, and the 3-indexed account is our general-purpose user. We also need to know the addresses of our deployed contracts, so let's use ", 'fs', ' to read the addresses JSON file and store that too.']
['The following functions are ', 'not', ' in the same task file but are imported from the ', './tasks/helpers/utils.ts', " file. It's just worth noting how it works. "]
["We're just going to call the above helper functions to fetch the data we need in our task. We only want the governance and addresses object:"]
["The last thing we've got to instantiate is our interface to the contract itself, there are many ways to do this, but we're going to use our imported type chain binding, and we'll start by connecting it to our governance signer."]
["Let's add the following line inside our task's callback function:"]
["So far, we've created a new Hardhat task, instantiated our signers, and instantiated an interface to our contract. We're just about ready to start sending transactions!"]
['Spin up your own blockchain with Hardhat and locally deploy your own Lens Protocol!']
["Alright, so we've got two terminals running in the Docker container we're running with Docker Compose. We will be using the first one to run our local blockchain and the second one to deploy the protocol.  "]
["Recall we're also using Hardhat, which provides a fantastic tool to spin up a local chain in mere seconds, complete with multiple mock pre-funded addresses to have fun with!"]
['CREATE 2 NEW TERMINALS WITHOUT DOCKER']
["Leave the previous terminal you used for docker alone and create 2 new terminals for running the commands. Ending up with 3 terminals in total. But remember you don't need docker for the new terminals."]
['In the ', 'first', ' terminal write:']
['This compiles everything, then spins up a custom local blockchain using Hardhat.']
['To ensure the safety of the Lens Protocol’s users and promote the development of a robust, constructive network, the protocol will be launched in a guarded manner, that is, controlled by a community multisig consisting of trusted parties throughout the Web3 ecosystem. The transition to multisig as well as the signers will be announced soon!']
['This multisig will be able to authorize the following actions: ']
['Notwithstanding its abilities, the multisig will not be able to do the following: ']
['For launch, all fees will be disabled and the following assets will be whitelisted:']
['Updated', ' ', '4 months ago', ' ']
['Modularity is at the core of the Lens protocol. Everything is built with community expansion and the continued development of new, innovative features in mind.']
['Modules are standalone, governance-whitelisted contracts that adhere to a specific interface. They hold state and are unlimited in potential scope beyond adhering to the interface.']
['There are three types of modules:']
['The Lens Protocol is a composable social graph protocol built to be community-owned and ever-evolving. It empowers its users by allowing them to decide ', 'how', ' they want their social graph to be built and how they want it to be monetized, if at all. ']
["Furthermore, the protocol is engineered with the concept of modularity at its core, allowing for an infinitely expanding amount of use cases. This, from the user's perspective, translates to a new paradigm of ownership and customization that isn't possible (or financially feasible) in Web2."]
['Updated', ' ', '11 months ago', ' ']
['Follow NFTs include built-in governance mechanisms -- any profile can spin up a DAO in minutes!']
['When following a profile, followers obtain a ', 'FollowNFT,', ' which is the core building block of the Lens Protocol social graph! From a technical perspective, these NFTs contain governance-specific logic that allows for the following:']
['Note that by default, delegation is inactive, so followers need to delegate, either to themselves or to another trusted user to partake in governance!']
["Now that's cool and all... But how do you ", 'use', ' this to build a ', 'DAO?']
["To spin up a DAO, all you've got to do is deploy a contract that interfaces with the Follow NFT's built-in functionality. It should allow for proposal creation and interface with the given profile's Follow NFTs to read governance power at the appropriate blocks for voting -- that's it!"]
["This section walks you through creating a profile from scratch, publishing a post, following collecting, and even creating our own custom module. We'll be using ", 'ethers', ', ', 'hardhat', ', and ', 'typescript', ' to interact with the protocol.']
["We'll work with the core repository, deploy the entire protocol in a local hardhat network and write some custom tasks to interact with it. Let's start with the repository and environment setup."]
['Before You Get Started']
["You're going to need to have ", 'Git', ' and ', 'Docker Compose', ' installed on your system (this helps keep consistency between development machines and reduces OS/versioning errors!)']
['Updated', ' ', '11 months ago', ' ']
["Before we start creating a profile, we've got a little housekeeping to do, and this will serve as a great test to see if everything's set up correctly. "]
["Upon deployment, the protocol is paused by default. Let's go ahead and unpause it by adding the following lines to our tasks' callback function:"]
["Note that we're typically using a wrapper instead of just sending the transaction; this simply ensures that we wait for the transaction to be mined before proceeding. "]
['As a quick side note, the smart contract ABI (Application Binary Interface) treats enums as regular unsigned integers, which also happens with our JavaScript/typescript code; so the ', 'ProtocolState', ' enum is just a set of integers behind the scenes!']
['Create file ', 'tasks/unpause.ts', ' with the following code:']
["And now it's the moment of truth! Go ahead and run it with the following command:"]
['if things go well, we should have the following output in our terminal:']
['This is great! 2 is the value for ', 'ProtocolState.Paused', ' and 0 is the value for ', 'ProtocolState.Unpaused', '.']
['In the ', 'second', ' terminal write:']
['This executes the ', 'full-deploy', ' Hardhat task (which you can find in the ', 'tasks', " directory) on the local hardhat network. Once that's done, you should see a list of all newly deployed addresses, don't worry about jotting it down as it's also copied to an ", 'addresses.json', " file in the repository's root directory. "]
["You'll also see all the executed transactions in the first terminal if you want to see what's happening behind the scenes. "]
["On that note, so far, we've spun up our local blockchain and deployed the entire protocol to it. It's time to create a profile and start interacting with it!"]
['Updated', ' ', '5 months ago', ' ']
['"Following" on the Lens Protocol differs from following in Web2 social applications. When users follow a profile on the Lens Protocol, they are given a Follow NFT, which creators and communities can encode with additional value. ']
['Profiles NFTs', ' can attach a particular Follow Module to each ProfileNFT, which contains all of the logic used to determine if a user attempting to follow the profile should be issued a Follow NFT. For example, a profile could attach a follow module that requires a user to pay 5 MATIC to receive a Follow NFT. ']
["The ID of each newly issued Follow NFT for given profile increments by 1, such that the first follower's NFT has an ID of 1; the tenth has an ID of 10, and so on. "]
['Additionally, Follow NFTs have built-in governance capabilities, such as vote delegation, to allow for the creation of Social DAOs using Lens Protocol. Creators, DAOs, or other organizations can create voting strategies using Follow NFTs and their various properties--for example: "The first 1000 follows have one vote each" or "The longer you have followed, the more voting power you have."']
['Collects allow creators to monetize their content.  Because creators own their content via the Lens Protocol, they are able to allow their followers to purchase that content.']
['When a user posts a ', 'publication', ' to their ', 'Profile NFT', " they have the option to set a Collect Module. This module will allow other users to mint NFTs that link to the publication's ContentURI. This module can contain any arbitrary logic to apply to the minting process and the resulting NFT."]
['A creator can attach a collect module that allows collecting to be open for a certain amount of time or only allow a certain number of collects. Developers can also make their collect modules to add even more functionality!']
['Updated', ' ', '11 months ago', ' ']
["Mirrors are the curation tool of the Lens Protocol. They are the protocol's equivalent to reposting or re-amplifying content. Mirrors are treated the same as ", 'publications', ' with a few additional checks and a few more minor features.']
["Since mirrors reference other publications, they are subject to the conditions of the original publication's Reference Module. If a publication has a reference module that limits mirrors only to accounts that follow the original poster, and the mirroring account does not hold a Follow NFT, the transaction to mirror will fail."]
['Since mirrors only repost existing content, they do not have a ContentURI field and therefore cannot be collected and do not have a Collect Module of their own. Mirrors can have their own reference module, which can define what accounts will be able to mirror or comment on the mirror.']
['Updated', ' ', '11 months ago', ' ']
['This is a beta API']
['This API is beta and not production complete yet, which means that we could change schemas and endpoints at any time without warning or notice to you. When this API is production ready, we will remove this beta warning and will endeavor to ensure that there are no changes going forward unless a major change to the protocol itself is required.']
['Welcome to the API docs for Lens Protocol.  We aim to highlight all the endpoints which are exposed on the public API and explain how to use them and what they return. ']
['The API is a GraphQL API which is very similar to how a lot of people use the subgraph when using The Graph so it should be very familiar for many developers. If you have come from a REST backend we will explain how you can easily get up and running with this on your client.']
['GraphQL gives us a lot of benefits but the main one is a schema first approach. We believe for mass adoption and building of Lens we need the tools to be super easy and abstract away as much as the blockchain stuff as we can. You will see how we did this with our schema, everything should just make sense without having a deep technical understanding of how the protocol works or having to understand Solidity.']
['As the protocol data on the blockchain is very relational, our indexer does all the work for you. Mapping it into our Postgres database decoded and in a relational manner optimized for fast fetching. This allows you to query us with the same speed as if you were querying Twitter for example. ']
['In a nutshell, a governance contract would need to handle...']
["But this is just a basic list of requirements and only scratches the surface of what's possible!"]
['Updated', ' ', '11 months ago', ' ']
['Next up, we will create a new task to whitelist the user and create our first profile!']
['Updated', ' ', '5 months ago', ' ']
['We look forward to seeing all of the new Follow Modules and Follower Governance strategies the community comes up with!']
['Updated', ' ', '11 months ago', ' ']
['We have packed the API with a lot of features and will be continuing to develop and improve it. By using this API in your application you automatically inherit many of these improvements.']
['We hope you like it and any feedback you have is extremely welcomed.']
['Updated', ' ', 'about 2 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/recommended-profiles.ts']
['The API right now has basic ways to get popular profiles. It does not support a paging list as of yet. The API will undergo continuous improvement to ensure that it is returning profiles that are more relevant to the user using machine learning. By using this API you inherit all improvements without needing to change code.']
['Updated', ' ', '3 months ago', ' ']
['Profiles can have interests so that the experience layer can filter and provide content that is more relevant and engaging to their audience. The Lens API supports the following interests categories, and subcategories:']
['Every profile has an owner and with that, we are building up an on-chain identity for these profiles. This allows you to do powerful things like knowing if that profile has a human behind it, showing the ens name, and a lot more. We keep building this and adding to this further soon enough. The on-chain identity object is not in all profile examples to not bloat the request. ']
["please note the example below doesn't pick all the content out of the publication it just shows you the field used to get that back."]
['https://raw.githubusercontent.com/Uniswap/sybil-list/master/verified.json']
['Updated', ' ', 'about 2 months ago', ' ']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to do a comment on a post from a profile on lens. Comments are still publications and have all the power a Post does. ']
["Some developers get confused when getting started on what is valid metadata and what is not. They miss a property or pass in a wrong type which is hard to debug if you do this. This endpoint allows you to pass in the metadata and see if it's valid, if it is not valid it tells you why. This is great for debugging when you're getting up and running with the LENS API. "]
['You can validate metadata v1 and metadata v2 within the request, in this example we just show validating on metadata v2 as this is the latest and suggested metadata to follow.']
['Updated', ' ', '3 months ago', ' ']
['Events are emitted at every state-changing function call, in addition to standard ', 'ERC721 events.', ' Events often include the timestamp as a specific parameter, which allows for direct consumption using a bloom filter without needing to fetch block context on every event.']
['Keep in mind that profile interests are now ', 'off-chain', ' and will be used only to curate the way that API serves content.']
['In addition, the API wants to stay unopinionated in terms of i18n and of how you choose to display interests to your users, so all interests are returned in english capitalised format, words are separated with underscore ', '_', ' and subcategories with double underscore ', '__', '.']
['Profiles can have up to 12 interests at this time. Will return null if successful, otherwise error. You need to be authorized with the provided ', 'profileId', ' to call.']
['As with the previous endpoint, this one also returns null on success otherwise error. You need to be authorized with the provided ', 'profileId', ' to call.']
['Updated', ' ', 'about 1 month ago', ' ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.']
['Hot tip']
["It's super easy to enable modules within your publication using this typed data approach as the server lifts all the encoding and decoding of the modules for you. This allows you to just supply it as you would if you were using a web2 API."]
["Let's touch on this request so it's super clear."]
['Furthermore, collect and follow NFT transfers hook into an event emitter on the LensHub, which simplifies event consumption by tracking NFT transfers without indexing numerous follow and collect NFTs.']
['The ', 'Events library', ' contains a convenient list of all custom Lens Protocol events as well as explanations for each. It also references the ', 'DataTypes library.']
['See the events emitted below:']
['event BaseInitialized(string name, string symbol, uint256 timestamp);']
["Emitted when the NFT contract's name and symbol are set at initialization by ", 'initialize()']
['event StateSet(address indexed caller, DataTypes.ProtocolState indexed prevState, DataTypes.ProtocolState indexed newState, uint256 timestamp);']
['Emitted when the hub state is set by ', 'setState()', ' ']
['event GovernanceSet(address indexed caller, address indexed prevGovernance, address indexed newGovernance, uint256 timestamp);.']
['Reference modules allow you to place criteria on the comment and mirror commands on who is actually allowed to do it. For example, a publication could set only their followers can comment and mirror. You need a way to quickly look this up for the selected profile the user is browsing on. In the ', 'canComment', ' field resolver you can pass in a ', 'profileId', "If you wish to know if they can comment or not, most apps would use the logged-in user's selected profile they are browsing on."]
["please note the example below doesn't pick all the content out of the publication it just shows you the field used to get that back. Also, note you can use ", 'canComment', ' anytime it returns a ', 'Post', ', ', 'Comment', ' or ', 'Mirror', '.']
["You need to know if the logged-in user has collected a publication it's viewing, to do this you need to look at the ", 'hasCollectedByMe', ' property on the publication response. This is shown in the examples when fetching back a publication. It will always be false if calling when not logged in but when passing in the auth header it will work out if that wallet has collected it already.']
["please note the example below doesn't pick all the content out of the publication it just shows you the field used to get that back."]
['Updated', ' ', '7 months ago', ' ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['As everything is an NFT in theory - even if it can not be collected - setting metadata standards is necessary for all publications. This will outline what we propose you should conform to if you are building on Lens Protocol. This does not mean you can not set up your own standards; rather, it means that our API will not index a publication unless it matches these standards. ']
['These standards can be continuously improved - and we are open to feedback from the community on how we can keep pushing the standards and making them better. ']
['Lens supports metadata that is structured according to the ', 'official ERC721 metadata standard', ' or the ', 'Enjin Metadata suggestions', '.']
['You have to pass in a ', 'profileId', ' that is mandatory.']
['You have to pass in a ', 'publicationId ', ' that is mandatory.']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['The metadata holds the main context of a publication, it holds your content, the media items attached to it, and is the metadata that people get when they collect. ', 'Metadata standards', ' are defined here if you want to read what standard we have set. The link passed to use must be able to be called from our server and hold the standards we set out or we will not index the publication.']
['Modules are quite complex, each module needs to be encoded in the correct way for the contracts not to throw. We tried to abstract any complex stuff out for you here and allow you to just pass in the params in web2 style. ']
['Please note you can only supply one of these if you supply more than one the API will throw. We have to do it this way with optional parameters as GraphQL does not support unions on request yet.']
['This module works by allowing anyone to collect with no fee or no limit or no time. It just allows anyone to collect your publication.']
['Emitted when the governance address is changed by ', 'setGovernance()', ' ']
['event EmergencyAdminSet(address indexed caller, address indexed oldEmergencyAdmin, address indexed newEmergencyAdmin, uint256 timestamp);']
['Emitted when the emergency admin is changed by ', 'setEmergencyAdmin()']
['event ProfileCreatorWhitelisted(address indexed profileCreator, bool indexed whitelisted, uint256 timestamp);']
['Emitted when a profile creator is added to or removed from the whitelist by ', 'whitelistProfileCreator()']
['event FollowModuleWhitelisted(address indexed followModule, bool indexed whitelisted, uint256 timestamp);']
['Emitted when a follow module is added to or removed from the whitelist by ', 'whitelistFollowModule()']
['Reference modules allow you to place criteria on the comment and mirror commands on who is actually allowed to do it. For example, a publication could set only their followers can comment and mirror. You need a way to quickly look this up for the selected profile the user is browsing on. In the ', 'canMirror', ' field resolver you can pass in a ', 'profileId', "If you wish to know if they can mirror or not, most apps would use the logged-in user's selected profile they are browsing on."]
["please note the example below doesn't pick all the content out of the publication it just shows you the field used to get that back. Also, note you can use ", 'canMirror', ' anytime it returns a ', 'Post', ', ', 'Comment', ' or ', 'Mirror', '.']
['profileId', ' for ', 'canMirror', " can pass in as a variable easily enough as well. You can imagine passing the logged-in user's profiles they are browsing on to see if they can comment on the publication. This can be hooked in like this for every query which returns a publication type (Post or Comment or Mirror)"]
['Updated', ' ', '3 months ago', ' ']
['profileId', ' for ', 'canComment', " can pass in as a variable easily enough as well. You can imagine passing the logged-in user's profiles they are browsing on to see if they can comment on the publication. This can be hooked in like this for every query which returns a publication type (Post or Comment or Mirror)"]
['Updated', ' ', '3 months ago', ' ']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API, the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.']
['Hot tip']
["It's super easy to enable modules within your publication using this typed data approach as the server lifts all the encoding and decoding of the modules for you. This allows you to just supply it as you would if you were using a web2 API."]
["Let's touch on this request so its super clear."]
['All Metadata standards we set are supported on OpenSea and other marketplaces.']
['Here is the full overview of the latest metadata standard we will go through each field below.']
['Please note that legacy metadata standards will not be talked about in this doc as we do not want to confuse new builders on what the standards are. Saying this we will always support old standards and migrate the data to keep them as close as possible to new metadata standards. ']
['Please note ', 'null', ' will be classed as undefined (optional parameters) if used. ']
['We expect this standard to keep growing as more is added, so defining the version number makes sense to allow us to parse it differently from the API standpoint. This doc will be kept updated with version changes.']
['The latest version to use when defining metadata version is - ', 'PublicationMetadataVersions.two', ' aka ', " '2.0.0'"]
["You need to know if the logged user has mirrored this publication it's viewing, to do this you need to look at the ", 'mirrors', ' property on the publication response. This returns an array of publications ids of the mirrored publication as a profile can mirror a publication many times. In the mirrors field resolver you can pass in a ', 'profileId', ' you wish to know the mirrrors state for, most apps would use the logged in users selected profile they are browsing on.']
["please note the example below doesn't pick all the content out of the publication it just shows you the field used to get that back."]
['profileId', ' for ', 'mirrors', ' can pass in as a variable easily enough as well. You can imagine passing the logged-in users profile they are browsing on to see if they have mirrored the publication. This can be hooked in like this for every query which returns a publication type (Post or Comment or Mirror)']
['Updated', ' ', '7 months ago', ' ']
['freeCollectModule object constraints']
['Usage:']
['This module works by disallowing all collects. If set if someone tried to collect from the contract level it would throw and revert.']
['Usage:']
['This collect module has no time limit, followers only unlimited mints, and an optional referral fee. ']
['feeCollectModule object constraints']
['Usage:']
['This collect module has no time limit, follower only limited mints, and an optional referral fee']
[' event ReferenceModuleWhitelisted(address indexed referenceModule, bool indexed whitelisted, uint256 timestamp);']
['Emitted when a reference module is added to or removed from the whitelist by ', 'whitelistReferenceModule()']
['event CollectModuleWhitelisted(address indexed collectModule, bool indexed whitelisted, uint256 timestamp);']
['Emitted when a collect module is added to or removed from the whitelist by ', 'whitelistCollectModule()']
['event ProfileCreated(uint256 indexed profileId, address indexed creator, address indexed to, string handle, string imageURI, address followModule, bytes followModuleReturnData, string followNFTURI, uint256 timestamp);']
[' event DispatcherSet(uint256 indexed profileId, address indexed dispatcher, uint256 timestamp);']
['You have to pass in a ', 'profileId', ' that is mandatory.']
['The metadata holds the main context of a publication, your content, as well as the media items attached to it, and is the metadata that people get when they collect. ', 'Metadata standards', ' are defined here if you want to read what standard we have set. The link passed to use must be able to be called from our server and hold the standards we set out or we will not index the publication.']
['The ', 'contentURI', ' can be either an IPFS or Arweave hash formatted in the following way:']
['Modules are quite complex, each module needs to be encoded in the correct way for the contracts not to throw. We tried to abstract any complex stuff out for you here and allow you to just pass in the params in web2 style. ']
['Please note you can only supply one of these if you supply more than one the API will throw. We have to do it this way with optional parameters as GraphQL does not support unions on request yet.']
['This module works by allowing anyone to collect with no fee or no limit or no time. It just allows anyone to collect your publication.']
['string']
['We force a metadata_id on the metadata because we would prefer content for each user is a different IPFS link if using IPFS. so having a metadata_id on here enforces that you want to make each publication for each person different even if they post the same content. You can create your own ids or use ', 'uuid', ' to make sure this will always be different when building up your metadata. ']
['Even though its optional we advise you to use this']
['Markdown', ' which is a schema type for string']
['As your publication can be NFT if collected, you can set a description for it which when you use opensea or other marketplaces it will show context about it to people who own it or may want to trade it.']
['Markdown', ' which is a schema type for string']
['limitedFeeCollectModule object constraints']
['Usage:']
['This collect module has 24 hours with a fee and optional referral fee, follower only limited mints']
['limitedTimedFeeCollectModule object constraints']
['Usage:']
['This collect module has 24 hours with a fee and optional referral fee, follower only unlimited mints']
['timedFeeCollectModule object constraints']
['Emitted when a dispatcher is set for a specific profile by ', 'setDispatcher()']
['event ProfileImageURISet(uint256 indexed profileId, string imageURI, uint256 timestamp);']
["Emitted when a profile's URI is set by ", 'setProfileImageURI()']
['event FollowNFTURISet(uint256 indexed profileId, string followNFTURI, uint256 timestamp);']
["Emitted when a follow NFT's URI is set by ", 'setFollowNFTURI()']
['freeCollectModule object constraints']
['Usage:']
['This module works by disallowing all collects. If set if someone tried to collect from the contract level it would throw and revert.']
['Usage:']
['This collect module has no time limit, followers only unlimited mints, and an optional referral fee. ']
['feeCollectModule object constraints']
['This contains your publication text. So if you write a post saying "Hello World" and attach an image the "Hello World" will be in that ', 'content', ' property.']
['This supports markdown as well. ']
['Locale', ' which is a schema type for string']
['IOS 639-1 language code aka en or it and ISO 3166-1 alpha-2 region code aka US or IT aka en-US or it-IT.']
['This field describes which language and region the text/media is in. You can just pass in the language if you do not know the region or care about the region. ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Usage:']
["This collect module is unknown and not type supported in the API. This means if you use this you have to encode and supply the data yourself to the API, the API will still allow you to use an unknown collect module but it won't validate it. Only use unknown collect modules if you can trust the collect module and know what you're doing."]
['Modules are quite complex, each module needs to be encoded in the correct way for the contracts not to throw. We tried to abstract any complex stuff out for you here and allow you to just pass in the params in web2 style.']
['A simple reference module that validates that comments or mirrors originate from a profile owned by a follower.']
['This is super easy to toggle just pass in the boolean in the ', 'followerOnlyReferenceModule', ' property and it turn it on and off for that publication. ']
['Usage:']
['This reference module allows you to set the degrees of separation in who can comment or mirror. If you do not know what degrees of separation you may have heard of the rule that with up to 6 links you can connect people together. With the protocol being open bots and spam is a things we want to handle and this tackles this. ']
['Spin up your own blockchain with Hardhat and locally deploy your own Lens Protocol!']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['event FollowModuleSet(uint256 indexed profileId, address followModule, bytes followModuleReturnData, uint256 timestamp);']
["Emitted when a profile's follow module is set by ", 'setFollowModule()']
['event PostCreated(uint256 indexed profileId, uint256 indexed pubId, string contentURI, address collectModule, bytes collectModuleReturnData, address referenceModule, bytes referenceModuleReturnData, uint256 timestamp);']
['Emitted when a "post" is published by either ', 'post()', ' or ', 'postWithSig()']
['event CommentCreated(uint256 indexed profileId, uint256 indexed pubId, string contentURI, uint256 profileIdPointed, uint256 pubIdPointed, address collectModule, bytes collectModuleReturnData, address referenceModule, bytes referenceModuleReturnData, uint256 timestamp);']
['Usage:']
['This collect module has no time limit, follower only limited mints, and an optional referral fee.']
['limitedFeeCollectModule object constraints']
['Usage:']
['This collect module has 24 hours with a fee and optional referral fee, follower only limited mints']
['limitedTimedFeeCollectModule object constraints']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['example - en-Us']
['example of just language - en']
['Both would be allowed. ']
['string[]', ' ']
['Ability to tag dynamically on a publication, this will allow you to do queries on these tags throughout the API. ']
['Ability to tag content warnings on publications if known already. These by default are hidden from the main APIs you have to explictly ask to include content warning types for them to come back in the queries. ']
['It is not required but if you try to put something outside of the enum above it be will be rejected by the indexer. ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['settings:']
['commentsRestricted', " -  Boolean - if it's set to true the degree of separation is applied if false it is not which means anyone can comment."]
['mirrorsRestricted', " -  Boolean - if it's set to true the degree of separation is applied if false it is not which means anyone can mirror."]
['degreesOfSeparation', ' - Int - Max 4 degrees']
["This reference module is unknown and not type supported in the API. This means if you use this you have to encode and supply the data yourself to the API, the API will still allow you to use the unknown reference module but it won't validate it. Only use unknown reference modules if you can trust the reference module and know what you're doing. "]
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Emitted when a "comment" is published by either ', 'comment()', ' or ', 'commentWithSig()']
['event MirrorCreated(uint256 indexed profileId, uint256 indexed pubId, uint256 profileIdPointed, uint256 pubIdPointed, address referenceModule, bytes referenceModuleReturnData, uint256 timestamp);']
['Emitted when a "mirror" is published by either ', 'mirror()', ' or ', 'mirrorWithSig()']
['event FollowNFTDeployed(uint256 indexed profileId, address indexed followNFT, uint256 timestamp);']
['Emitted when a ', 'followNFT', ' clone is deployed using a lazy deployment pattern i.e. in case Follow NFT contract does not already exist when either ', 'follow()', ' or ', 'followWithSig()', ' is called.']
['Usage:']
['This collect module has 24 hours with a fee and optional referral fee, follower only unlimited mints']
['timedFeeCollectModule object constraints']
['Usage:']
["This collect module is unknown and not type supported in the API. This means if you use this you have to encode and supply the data yourself to the API, the API will still allow you to use an unknown collect module but it won't validate it. Only use unknown collect modules if you can trust the collect module and know what you're doing. "]
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Main publication focus is one of the main ways you can add a category for the publication. For example, if you are uploading an image and content then it should be tagged as IMAGE as the main publication focus is that. This will allow clients to build really nice layouts for each main focus. All these main publication focus are filterable on all queries allowing you to bring it whichever you decide your app wants. Data migration has been run on old metadata standards so every publication will have a ', 'mainPublicationFocus', ' - be as creative as you wish!']
['formats:', '\n- video/webm', '\n- video/mp4', '\n- video/x-m4v', '\n- video/ogv', '\n- video/ogg']
['formats:', '\n- image/gif', '\n- image/jpeg', '\n- image/png', '\n- image/tiff', '\n- image/x-ms-bmp', '\n- image/svg+xml', '\n- image/webp']
['formats:', '\n- audio/wav', '\n- audio/mpeg', '\n- audio/ogg']
['Url', ' which is a schema type for string']
["This is the URL that will appear below the asset's image on OpenSea and others etc and will allow users to leave OpenSea and view the item on the site. You could use this as a deep link into your dApp or something else. "]
['The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. ', 'You must enable Javascript in your browser in order to decode the e-mail address', '.']
['If you have a website and are interested in protecting it in a similar way, you can ', 'sign up for Cloudflare', '.']
['\n    ', 'Cloudflare Ray ID: ', '782f33b9ffacb494', '\n    ', '•', '\n    ', '\n      Your IP:\n      ', 'Click to reveal', '\n      ', '67.42.175.62', '\n      ', '•', '\n    ', '\n    ', 'Performance & security by', ' ', 'Cloudflare', '\n    \n  ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['The API will support more modules which get whitelisted as they get approved.']
['as they do this doc will be updated alongside it.']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/comment.ts', ' shows you a live running example of how you would generate the signed typed data from the API and send it through the ', 'withSig', ' methods. ']
['If you are on mumbai anyone can use gasless but if your on polygon only whitelisted apps can currently use this']
['You have 2 options when doing gasless you have ', 'broadcast', ' and also the ', 'dispatcher', '. The dispatcher supports a subset of methods that allows you to do actions without signing, these actions are protocol calls that can not drain funds from any wallet making them classed as safe actions, not all methods are supported by the dispatcher. Posting is one of those allowed dispatcher methods. You can set up a dispatcher for the user using ', 'https://docs.lens.xyz/docs/create-set-dispatcher-typed-data', ' and then broadcast that transaction which is described in that document. ']
['Full code example of gasless']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/comment-gasless.ts']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['event CollectNFTDeployed(uint256 indexed profileId, uint256 indexed pubId, address indexed collectNFT, uint256 timestamp);']
['Emitted when a ', 'collectNFT', ' clone is deployed using a lazy deployment pattern i.e. in case collect NFT contract does not already exist when either ', 'collect()', ' or ', 'collectWithSig()', ' is called.']
['event Collected(address indexed collector, uint256 indexed profileId, uint256 indexed pubId, uint256 rootProfileId, uint256 rootPubId, uint256 timestamp);']
['Emitted upon a successful collect action by either ', 'collect()', ' or ', 'collectWithSig()']
['event FollowNFTTransferred(uint256 indexed profileId, uint256 indexed followNFTId, address from, address to, uint256 timestamp);']
['Modules are quite complex, each module needs to be encoded in the correct way for the contracts not to throw. We tried to abstract any complex stuff out for you here and allow you to just pass in the params in web2 style.']
['A simple reference module that validates that comments or mirrors originate from a profile owned by a follower.']
['This is super easy to toggle just pass in the boolean in the ', 'followerOnlyReferenceModule', ' property and it turns it on and off for that publication. ']
['Usage:']
['This reference module allows you to set the degrees of separation in who can comment or mirror. If you do not know what degrees of separation you may have heard of the rule that with up to 6 links you can connect people together. With the protocol being open bots and spam is a things we want to handle and this tackles this. ']
['settings:']
['commentsRestricted', " -  Boolean - if it's set to true the degree of separation is applied if false it is not which means anyone can comment."]
['You can only suggest edits to Markdown body content, but not to the API spec.']
['string']
['This is the name of your publication this is a key bit of data OpenSea uses to show the NFT so we have enforced it to make sure no bad NFTs are created.']
['Please supply an empty array if no attributes are present as recommended best practice.']
['To give your publication a little more detail, OpenSea and other marketplaces allow you to add custom "attributes" to your metadata that will show up underneath each of your assets. Remember a publication only becomes an NFT if collected. ']
['These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item. ']
['Url', ' which is a schema type for string.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['This doc ', 'https://docs.lens.xyz/docs/broadcast-transaction', ' explains how you would broadcast a transaction with the demo example in there. You basically use all of the examples in the GitHub code snippet but instead of calling the ', 'withSig', ' methods on the hub directly, you pass the signature into the broadcast call. This is all shown in the full code GitHub example above.']
['This takes in the same request as the ', 'withSig', ' method so nothing needs to change in that regard. You then can track the ', 'txId', ' to see what it is indexed. Look at the code examples for more low-level detail.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', '3 months ago', ' ']
['Emitted via callback when a followNFT is transferred.']
['event CollectNFTTransferred(uint256 indexed profileId, uint256 indexed pubId, uint256 indexed collectNFTId, address from, address to, uint256 timestamp);']
['Emitted via callback when a collectNFT is transferred.']
['event FollowNFTDelegatedPowerChanged(address delegate, uint256 newPower, uint256 timestamp);']
['Emitted when a newly deployed follow NFT is initialized.']
['event FollowNFTDelegatedPowerChanged(address delegate, uint256 newPower, uint256 timestamp);']
['Emitted when delegation power in a FollowNFT is changed.']
['mirrorsRestricted', " -  Boolean - if it's set to true the degree of separation is applied if false it is not which means anyone can mirror."]
['degreesOfSeparation', ' - Int - Max 4 degrees']
["This reference module is unknown and not type supported in the API. This means if you use this you have to encode and supply the data yourself to the API, the API will still allow you to use the unknown reference module but it won't validate it. Only use unknown reference modules if you can trust the reference module and know what you're doing. "]
['The API will support more modules which get whitelisted as they get approved.']
['as they do this doc will be updated alongside it.']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/post.ts', ' shows you a live running example of how you would generate the signed typed data from the API and send it through the ', 'withSig', ' methods. ']
['If you are on mumbai anyone can use gasless but if your on polygon only whitelisted apps can currently use this']
['We have brought in a new type called ', 'media', ' which supports more than just images which we will cover down below but as publications can be NFTs if collected, you must still supply the NFT image link else it will not render an image on opensea if collected by someone. This is the NFT visual the person will be collecting. ']
['Some rules to follow which will allow this to work all the time:']
['Remember people can upload many images/videos/audio items to media as this is the more social aspect of the metadata but the NFT image itself must only be 1. Make sure you always supply it as what you want the users to see in their wallets when they collect your publication. ']
['If you are uploading a video or audio to be collected that needs to go in ', 'animation_url', ' but the cover for it needs to go in ', 'image', ' as well. ']
['imageMimeType', ' which is a schema type for string']
['currently supporting image mime types:']
['event CollectNFTInitialized(uint256 profileId, uint256 pubId, uint256 timestamp);']
[' Emitted when a newly deployed collect NFT is initialized.']
['event ModuleGlobalsGovernanceSet(address indexed prevGovernance, address indexed newGovernance, uint256 timestamp);']
['Emitted when the ModuleGlobals governance address is set.']
['event ModuleGlobalsTreasurySet(address indexed prevTreasury, address indexed newTreasury, uint256 timestamp);']
['Emitted when the ModuleGlobals treasury address is set.']
['event ModuleGlobalsTreasuryFeeSet(uint16 indexed prevTreasuryFee, uint16 indexed newTreasuryFee, uint256 timestamp);']
[' Emitted when the ModuleGlobals treasury fee is set.']
['You have 2 options when doing gasless you have ', 'broadcast', ' and also the ', 'dispatcher', '. The dispatcher supports a subset of methods that allows you to do actions without signing, these actions are protocol calls that can not drain funds from any wallet making them classed as safe actions, not all methods are supported by the dispatcher. Posting is one of those allowed dispatcher methods. You can set up a dispatcher for the user using ', 'https://docs.lens.xyz/docs/create-set-dispatcher-typed-data', ' and then broadcast that transaction which is described in that document. ']
['Full code example of gasless']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/post-gasless.ts']
['This doc ', 'https://docs.lens.xyz/docs/broadcast-transaction', ' explains how you would broadcast a transaction with the demo example in there. You basically use all of the examples in the GitHub code snippet but instead of calling the ', 'withSig', ' methods on the hub directly, you pass the signature into the broadcast call. This is all shown in the full code GitHub example above.']
['This takes in the same request as the ', 'withSig', ' method so nothing needs to change in that regard. You then can track the ', 'txId', ' to see what it is indexed. Look at the code examples for more low level detail.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Sometimes the IPFS link which is passed to the image metadata does not contain the content header for the image. This can cause some issues rendering; to protect against this, when you upload an image make sure you put its mime type in this property as well. This will mean all UIs who build on lens can always render it on their UI. ']
['MetadataMedia[]']
['You can upload an array of images/videos/audios you wish to share with your audience.']
['Url', ' which is a schema type for string']
['A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.']
['Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['event ModuleGlobalsCurrencyWhitelisted(address indexed currency, bool indexed prevWhitelisted, bool indexed whitelisted, uint256 timestamp);']
['Emitted when a currency is added to or removed from the ModuleGlobals whitelist.']
['event FeeModuleBaseConstructed(address indexed moduleGlobals, uint256 timestamp);']
['Emitted when a module inheriting from the ', 'FeeModuleBase', ' is constructed.']
['event ModuleBaseConstructed(address indexed hub, uint256 timestamp);']
['Emitted when a module inheriting from the ', 'ModuleBase', ' is constructed.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Updated', ' ', '24 days ago', ' ']
['string']
['You may want to tag the publication with an ', 'appId', ' this will then allow you to filter on that ', 'appId', ' for publications on the ', 'Publication', ' queries.']
['Updated', ' ', '3 days ago', ' ']
['event FollowsApproved(address indexed owner, uint256 indexed profileId, address[] addresses, bool[] approved, uint256 timestamp);']
['Emitted when one or multiple addresses are approved (or disapproved) for following in the ', 'ApprovalFollowModule', '.']
['Updated', ' ', '5 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['usePublication', " is a React hook that allows you to find a specific publication using it's identifier."]
['The id of the publication to fetch']
['The id of the profile who is running the query, usually the logged in/active profile.']
['useProfileFollowers', ' is a React Hook that lets you query the followers of a profile.']
['profileId: string', ' (required)']
['observerId: string', ' (optional)']
['limit: number', ' (optional)']
['Updated', ' ', '9 days ago', ' ']
['useMutualFollowers', ' is a React Hook that lets you query the followers in common between two profiles.']
['observerId: string', ' (required)']
['viewingProfileId: string', ' (optional)']
['limit: number', ' (optional)']
['Updated', ' ', '9 days ago', ' ']
['Updated', ' ', '9 days ago', ' ']
['Install ', '@lens-protocol/react', ' and ', 'ethers', ' dependency.']
['useProfile', ' is a React Hook that lets you fetch a Lens profile by handle or by profile ID.']
['The hook will throw an error if both ', 'handle', ' and ', 'profileId', ' are defined']
['Updated', ' ', '9 days ago', ' ']
['useWalletLogout', ' is a React Hook that lets you log out the previously authenticated user. You have to be authenticated before calling ', 'logout', '.']
['Call ', 'useWalletLogout', ' in the component responsible to log out your users.']
['useWalletLogout', ' does not take any parameters.']
['The ', 'logout', ' function you can use to programmatically log out currently logged-in user.']
['Updated', ' ', '9 days ago', ' ']
['useWalletLogin', ' is a React Hook that lets you authenticate with the Lens API.']
['Although the following example uses ', 'wagmi', ' it can be adapted to any wallet integration that results in an ', 'ethers', ' ', 'Signer', '.']
['You can then pass the ', 'onLoginClick', ' handler to your JSX:']
['Call ', 'useWalletLogin', ' in the component responsible to log in your users.']
['Updated', ' ', '9 days ago', ' ']
['Although ', '@lens-protocol/react', ' only depends on ', 'ethers', ' (and React ofc), we created a companion package called ', '@lens-protocol/wagmi', ' which makes it easier to integrate it with the popular ', 'wagmi', ' library.']
['Ensure you have Polygon in the wagmi chains configuration']
['Refer to ', 'wagmi', ' docs to see how to set up custom chains, providers and work with their client.']
['The example above uses ', 'localStorage()', ' adapter for ', 'window.localStorage', ', which is available only on web browsers.', '\nLater on we will provide guidance on how to provide a reliable storage solution for React Native or roll your own storage provider solution.']
["It's not strictly necessary to have the ", 'LensProvider', ' as child of the ', 'WagmiConfig', '.']
['You are good to go!']
['Updated', ' ', '6 days ago', ' ']
['There are several major reasons we have decided to use GraphQL over a REST architecture: ']
['All the types (such as Boolean, String, Int, Float, ID, Scalar) supported by the API are specified in the schema in GraphQL Schema Definition Language (SDL), which helps determine the data that is available and the form it exists in. This, consequently, makes GraphQL less error-prone, and more validated, and provides auto-completion for supported IDE/editors. With a protocol that holds a lot of complexity, this really empowers the developer to understand the protocol just by looking at the schema which is super powerful.']
['GraphQL allows making multiple resources request in a single query call, which saves a lot of time and bandwidth by reducing the number of network round trips to the server. It also helps to save waterfall network requests, where you need to resolve dependent resources on previous requests']
['In REST architecture, developers create new versions (e.g., api.domain.com/v1/, api.domain.com/v2/) due to changes in resources or the request/response structure of the resources over time. Hence, maintaining versions is a common practice. With GraphQL, there is no need to maintain versions. The resource URL or address remains the same. You can add new fields and deprecate older fields. This approach is intuitive as the client receives a deprecation warning when querying a deprecated field.']
['With GraphQL, developers can fetch only what is required. Nothing less, nothing more. This solves the issues that arise due to over-fetching and under-fetching. You define how big your payload response should be!']
['useWalletLogin', ' does not take any parameters.']
['The ', 'login', ' function you can use to programmatically log in your user with the Lens API.']
['The ', 'login', ' function returned by the ', 'useWalletLogin', ' lets you programmatically login the specified ', 'ethers', ' ', 'Signer', '. If called multiple times it will re-trigger a new login flow. If called with a different signer it will implicitly log-out the old signer and log-in the new one.']
['Updated', ' ', '9 days ago', ' ']
['We have been working closely with the fantastic XMTP to get E2EE DMs into the lens. They have now applied it to lenster but the standards are set to allow any lens app to inherit it.']
['The main API backend stack is written in ', 'node', ' and uses ', 'TypeScript', '. We also have crons which run in ', 'rust', ' and we migrating more of our crons into ', 'rust', ' as we continue developing the solutions.']
['Updated', ' ', '3 months ago', ' ']
['The main reason is that we know the community use subgraphs on The Graph a lot and know how the syntax works so we think it will not be a learning curve at all for a lot of people who want to build on top of lens. ']
['We have loads and loads more reasons but yeah we love ', 'GraphQL', ' and works perfectly for our need here.']
['Updated', ' ', '10 months ago', ' ']
['We use ', 'postgres', ' database to store all our data. We wanted to ensure certainty in every aspect of how the data can be queried and how fast it can be queried. With speed in our minds, we had to go for the more low-level database over for example ', 'NoSql', ' databases.']
['Updated', ' ', '10 months ago', ' ']
['We use Redis for caching everything. The issue you face with caching with a social media site is that you want data to be broadcasted as fast as possible but you want to also keep the speed impact of getting it. Our cache policy caches the generic data -- that is, if a user queries their timeline, they will always get back the latest stuff because the initial lightweight query of bringing back all the ids but the publication themselves have heavy caching on it. This allows us to still broadcast the latest data as soon as it is available but also have super fast queries for every API endpoint. The busier we are the faster we become. Speed is super important and improving this all the time will be something we constantly keep looking at.']
['Updated', ' ', '10 months ago', ' ']
['The backend server has many cron jobs which run individually; they all have a job to do, and to do it well they do. With the crons, we have a shared Redis cache to share states between them if they need to talk to each other. One cron is in charge of getting the latest block number and pushing changing state of that block number to Redis and another is in charge of reacting when the block number changes to access if anything in that block has changed for the lens protocol itself.']
['We heavily use ', 'bloomFilters', ' to check without any JSON RPC calls if the event and the lens contract are present in that block, if it is not we do nothing if it is we then get the logs for those events based on the topic and index it into our database. Our indexer also turns the data into a relational state, we do not just index the raw events we turn this data into already pre-formatted ready-to-go data, and save it in a structured highly relational database structure. This then means we can achieve super-fast queries with all the decoding already done for us within the indexer itself. Every event runs independently of itself allowing them all to access the block at the same time without blocking each other which increases the speed of broadcasting to anyone using our API. Alongside this we do not save as we see either. The server will generate everything which has changed in this block and then save in 1 database transaction meaning debugging is very easy and everything is transactional like how the blockchain is in theory. ']
['These tech decisions allow us to index super fast and only hit our node provider when we need to due to highly using blooms. Alongside super-fast queries and everything formatted and saved in the database in a relational optimized manner. ']
["As everyone knows reorgs can happen and they can happen many blocks in the future. Even though our node provider alchemy is a rockstar and protects us as much as they can sometimes it's out of their control if a reorg happens. Every part of the data saved on the database level which came from the protocol is attached next to a ", 'blockHash', ' and ', 'blockNumber', '. Alongside this, we also have a block safe table that inserts any blocks we index with the block hash and block number as well. Our reorg cron checks the ', 'blockHash', ' still exists after 300 blocks which are 3x the highest alchemy has ever seen a reorg happen on Polygon. If the ', 'blockHash', ' does not exist anymore we revert the data inserted/updated in our database and use the old values if they existed before. If the ', 'blockHash', ' still exists we mark this ', 'block', ' as safe and do not re-evaluate the data again.']
['Like OpenSea when the indexer sees your publication content come in we move it to our own storage and index the data at that time like a snapshot. Say you publish a post and the content points to your s3 box once the indexer picks it up it snapshots it and then going forward we read it from our own storage due to speed but also due to links being taken down and loads more reasons. This means if you did change that s3 link you used to point the publication to then it would not change on our API.']
['We are huge fans of ', 'The Graph', ' and the ability to spin up subgraphs is amazing. As a team experienced working on subgraphs, we wanted to ensure smooth and efficient functioning for the Lens Protocol API.']
['The subgraph sometimes takes a while to broadcast the indexed event. Now when we are building a social protocol we need the data to be ready at the second it has been mined in the block. Having this big dependency over our heads and not being able to control it would deeply ruin the whole network effect of the API. Speed is critical.']
['We slightly touched on this above but we want to be able to be in control if things go wrong and have the ability to fix it. Having our own in-house indexer allows us to fine-tune it and fix any bugs which arise. Additionally, having all the code in-house allows us to have higher uptime and fix any issues fast, without a third-party dependency. ']
['This data is highly relational. With social data and unlimited pointers, the data becomes highly relational very fast, especially when a publication starts getting attention. This means we need to structure this data in a relational manner to allow it to be fast and scale well. Having Postgres as our database allows us to do this really nicely. ']
['There are many more reasons why we went down the path of creating an indexer, but our main goal was to give Lens developers the best infrastructure possible, and to allow developers to be able to build applications that can scale and compete with the largest networks today.']
['Updated', ' ', '10 months ago', ' ']
['Updated', ' ', '10 months ago', ' ']
['We will expose this logic in our LENS SDK once an official one is supported. This will abstract all of this way for you and we will be building call features on top of XMTP core features. Stay tuned!']
['If you wish to hook it into one of your lens powers apps today go and check out the guides ', 'https://xmtp.to/lens-quickstart']
['Updated', ' ', 'about 2 months ago', ' ']
['Full code example']
['Updated', ' ', '8 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/revenue/publication-revenue.ts']
['This query returns the amounts earned on the requested publication.']
["Feed is one of the most fundamental elements that a successful social media site needs. It can be used to show the user what is happening on the social feeds of people they follow and what they like. The feed queries will get smarter, eventually bringing in AI and data profiling. We will continue to improve what data is returned by the API. The beauty of this is if you use the API you just inherit this functionality without having to update anything. This also is fully open so if you wish to see someone else's feed just supply their profile id in!"]
['If one of the profiles you follow posts it will appear on your timeline.']
['If one of the profiles you follow comments on a publication it will appear on your timeline.']
['If one of the profiles you follow mirrors a publication it will appear in your timeline. Remember people can mirror a post or a comment. ']
['If one of the profiles you follow collects a post or a comment it will appear on your timeline.']
['If one of the profiles you follow reacts to a publication it will appear on your timeline.']
['https://github.com/lens-protocol/api-examples/blob/master/src/timeline/user-timeline.ts']
['This endpoint will be removed on the 15th November! Please use the profile feed endpoint instead']
["Timeline is one of the most fundamental elements a successful social media site needs. It can be used to show the user what is happening on the social feeds of people they follow and what they are liking. The timeline queries will continue to get smarter, eventually bringing in AI and data profiling. We will continue to improve what data is returned by the API. The beauty of this is if you use the API you just inherit this functionality without having to update anything. This also is fully open so if you wish to see someone else's feed just supply their profile id in!"]
['Presently, for the Beta release, the timeline just brings back content in date order. ']
['If one of the profiles you follow posts it will appear on your timeline.']
['If one of the profiles you follow comments on a publication it will appear on your timeline.']
['If one of the profiles you follow mirrors a publication it will appear in your timeline. Remember people can mirror a post or a comment. ']
['If one of the profile wallet owners you follow collects a post it will appear on your timeline. Remember profiles do not collect wallets do but it is also a key action that we wanted on the timeline API. ']
['Feeds(timelines) is one of the most fundamental elements to create a successful social media site. It can be used to show the user what is happening on the social feeds of people they follow and what they are liking. The timeline queries will continue to get smarter, eventually bringing in AI and data profiling. We will continue to improve what data is returned by the API. The beauty of this is if you use the API you just inherit this functionality without having to update anything.']
['Our timeline resolver has these queries:']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['Search profiles - ', 'https://github.com/lens-protocol/api-examples/blob/master/src/search/search-profiles.ts']
['Search publications - ', 'https://github.com/lens-protocol/api-examples/blob/master/src/search/search-publications.ts']
['This query allows you to search across hashtags on publications or profile handles. This query returns either a ', 'Post', ' and ', 'Comment', ' or ', 'Profile', '. ']
['Querying the protocol publications for content and profiles is fundamental for social visibility and something we will continue to improve on.']
['You can search against profile handles or search against hashtags. Both will be explained in detail below. ']
['Hot tip']
['Search is fundamental to any application leveraging the Lens Social Graph. Our current search query allows you to search across hashtags on publications or profile handles. This query returns either a ', 'Post', ' and ', 'Comment', ' or ', 'Profile', '. ']
['Querying the protocol publications for content and profiles is fundamental for social visibility and something we will continue to improve on.']
['Our search resolver has these queries:']
['Updated', ' ', '10 months ago', ' ']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/revenue/profile-follow-revenue.ts']
['This query returns the amounts earned on the requested profile for all follows. It will group them up by currency.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/revenue/profile-publications-revenue.ts']
['This query returns the amounts earned on the requested profile for all publications. It will only return publications that have earned any fees. ']
["Below is an example of a request to get a feed for a profile. Feeds are fully open so anyone can see what another profile's feed looks like. This is also aggregated per page so you do not see repeated data, you will of course always get some loop over but that is the same on big social media sites. The main aim is for you to see all the information nicely. We talk about the response in more detail below. Please note the limit is the number of EVENTS you get back it is not the total count of aggregate lines. For example, if you asked for 5 and that all have been aggregated into one feed item you only get 1 back, we advise you use a limit of 50 for this which should give plenty of information for the user to see and page nicely."]
['The response is aggregated for you to allow you to build really nice feeds. ']
['This contains the feed item root which is a POST or a COMMENT, this is the main context around your feed item.']
['When a user collects it should collect the elected mirror id so that the user can get some profits for the collect if referral fees are set. This is sharing the elected mirror what this means is the first person in that aggregation who mirrored is elected. ']
['mirrorId', ' - the publication mirror id']
['profile', ' - the profile who has got elected for this']
['timestamp', ' - when that was mirrored']
['The profiles which have mirrored this publication in the aggregation. The first 1 in the array is the most recent profile to mirror. ']
['profile', ' - the profile that mirrored ']
['If one of the profile wallet owners you follow collects a post it will appear on your timeline. Remember profiles do not collect wallets do but it is also a key action that we wanted on the timeline API. ']
['Below is the overview of the entire interface but we dig into specific queries below.']
['Hot tip']
['If you do not know GraphQL that well remember things can be nullable if defined as so in the schema how GraphQL knows its nullable is without the ', '!', ' at the end here is an example:']
['Not nullable: ']
['ownedBy: EthereumAddress!']
['Nullable:']
['If you do not know GraphQL that well remember things can be nullable if defined as so in the schema how GraphQL knows its nullable is without the ', '!', ' at the end here is an example:']
['Not nullable: ']
['ownedBy: EthereumAddress!']
['Nullable:']
['ownedBy: EthereumAddress']
["It's always worth generating the TypeScript types for the schema if your application is TypeScript here is a reference to how you would do that - ", 'https://www.apollographql.com/blog/tooling/apollo-codegen/typescript-graphql-code-generator-generate-graphql-types/']
['You will see the paging result behavior repeated a lot in the API.  This is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result, you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
['You will see the paging result behavior repeated a lot in the API.  This is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result, you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
['The request also takes in:']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/reporting/report-publication.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['This mutation report publication allows a user to report something with a reason.']
['timestamp', ' - when that was mirrored']
['The profiles which have collected this publication in the aggregation. The first 1 in the array is the most recent profile that collected. ']
['profile', ' - the profile collected']
['timestamp', ' - when that profile collected']
['The profiles that reacted to the publication in the aggregation. The first 1 in the array is the most recent profile that has reacted. ']
['profile', ' - the profile that reacted']
['reaction', ' - the reaction type']
['ownedBy: EthereumAddress']
["It's always worth generating the TypeScript types for the schema if your application is TypeScript here is a reference to how you would do that - ", 'https://www.apollographql.com/blog/tooling/apollo-codegen/typescript-graphql-code-generator-generate-graphql-types/']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
["Let's look into the request a little more:"]
['profileId', ' is required - because a wallet can have many profiles the logged-in user must species which ', 'profileId', ' they wish to get back on the timeline. ']
['Publications ', 'Metadata standards', ' highlight that you can pass in an ', 'AppId', ' into the metadata and allow you to tag the content with a source. You can use "sources" in the request to only bring back data relevant to that source. This means UI can have different timelines depending on their sources. ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
[' You can use the ', 'type', ' property on the request which allows you to search on the same endpoint to define the type of search you want.']
['For now, the search will search across anything which has hashtags and tags, this will be expanded to a full-text search soon. So if someone posted #foo that can be searched but if someone posted "I like #foo" only "foo" would be searchable and not "like". A full-text search API is under active development and will be released at a later point. ']
['Updated', ' ', '3 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['With built-in ways to earn on Lens Protocol; but you need a way to be able to see a breakdown of the amount / value of what you have earned. For now, we only have a single query to get top-level revenue but later on, we will extend this to allow you to query into the revenue publication itself to see all the details.']
['Our revenue resolver has these queries:']
['Updated', ' ', '9 months ago', ' ']
['returns a ', 'VoidScalar', ' which means no response is returned if you do look at the response data it will be data.reportPublication= null but you do not need to look at the response for anything which returns ', 'void', '. If it does not throw it is successful. ']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
["Let's look into more detail of the ", 'reason', ' part of the request as there are many ways you can report.']
['The ', 'reason', ' is an object of 3 things ', 'sensitiveReason', ', ', 'illegalReason', ' , ', 'fraudReason', ' due to not being able to do unions in GraphQL you should only pass 1 in of those properties. The beauty of GraphQL is that the schema will explain how those types should be shaped and export the enums for you as well.']
['timestamp', ' - when they reacted ']
['The comments were published to the publication in the aggregation. The first 1 in the array is the most recent comment.']
['Updated', ' ', '2 months ago', ' ']
['Ability to only include the types of stuff you see on the timeline. To use just include the types you wish to bring back if you do not supply anything then it will bring back them all.']
['Timeline responses with ', 'union Publication = Post | Comment | Mirror', ' however below we will provide ways to distinguish between them and how to link the various types together.']
['Collecting...']
['Because we want to push the social graph for the original author of the publication if someone collects a mirror it will mark it as if they have collected the main publication from the timeline point of view.']
['Updated', ' ', '3 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Updated', ' ', '3 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['The reporting resolver to allow users to report things that may cause offense. ']
['Our reporting resolver has these queries:']
['Updated', ' ', '10 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/reaction/who-reacted-publication.ts']
['This query returns all the profiles who reacted to the publication. ']
['Use the GraphQL schema...']
['One of the huge advantages of GraphQL is you have a schema that should explain how the schema should look at what properties exist in that. In these docs we explore code examples and explain key concepts but we will not explain each property that exists in the response for example, as the schema already does that!']
['Updated', ' ', '3 months ago', ' ']
['To get the reaction you have to use the field resolver ', 'reaction', ' passing in a ', 'profileId', '. ']
['Below is a publications query that gets all the publications for profile ', '0x09', '. In the reaction field resolver you can pass in a ', 'profileId', ' you wish to know the reaction state for, most apps would use the logged in users selected profile they are browsing on.']
["please note the example below doesn't pick all the content out of the publication it just shows you the field used to get that back."]
['profileId', ' for ', 'reaction', ' can pass in as a variable easily enough as well. You can imagine passing the logged-in users profile they are browsing on to see if they have reacted to the publication. This can be hooked in like this for every query which returns a publication type (Post or Comment or Mirror)']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/reaction/remove-reaction.ts']
['This API call allows you to remove a react from publications with a profile off-chain without needing to sign. For now, reactions are stored on the server but we working on a way to decentralised likes without making UX really horrible with signing on every single reaction. ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Add a reaction to a publication, please note if you pass in another reaction it will toggle it. What I mean by that is if you ', 'UPVOTE', ' it then ', 'DOWNVOTE', ' it the server will swap the ', 'UPVOTE', ' to the ', 'DOWNVOTE', '.']
['This returns a void so no need to care about its response if successful. ']
['The profile id you wish to remove the react from, the authenticated user must own that profile. ']
['The reaction you want to remove from the publication, we support ', 'UPVOTE', ' and ', 'DOWNVOTE', ' dApp can make them work as they wish for example on lenster they have a heart button that only uses ', 'UPVOTE', ' but other dApp use both. ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/reaction/add-reaction.ts']
['This API call allows you to react to publications with a profile off-chain without needing to sign. For now, reactions are stored on the server but we working on a way to decentralised likes without making UX really horrible with signing on every single reaction. ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Add a reaction to a publication, please note if you pass in another reaction it will toggle it. What I mean by that is if you ', 'UPVOTE', ' it then ', 'DOWNVOTE', ' it the server will swap the ', 'UPVOTE', ' to the ', 'DOWNVOTE', '.']
['The reaction resolver allows the profile to react to publications off-chain. ']
['Updated', ' ', '7 months ago', ' ']
['which publication do you wish to remove reaction from']
['Updated', ' ', '12 days ago', ' ']
['This returns a void so no need to care about its response if successful. ']
['The profile id you wish to react from the authenticated user must own that profile. ']
['currently, we support ', 'UPVOTE', ' and ', 'DOWNVOTE', ' dApp can make them work as they wish for example on lenster they have a heart button that only uses ', 'UPVOTE', ' but other dApp use both. ']
['which publication do you wish to react to']
['Updated', ' ', '12 days ago', ' ']
['Please note you can use broadcast freely on mumbai but if you want to use it on polygon you need to be whitelisted.']
['This is quite low level']
["As you can filter queries by sources this means comments on a publication may be different numbers. Let's look at an example:"]
["Josh's post has 3 comments but across many apps. When you filter on sources you only bring back the sources from those apps. This example below its showing you how we get publication ID ", '0x01-0x01', ' and we get back the number of comments that have been done on the app ', 'your_app_id', '. This allows us to get the correct counters etc. ']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/profile-publications-for-sale.ts']
['This query returns you all the publications that are on sale for the profile.']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property.']
['You must supply the ', 'profileId', ' you wish to get all the publications they have for sale']
['Updated', ' ', '3 months ago', ' ']
['This endpoint allows you to do actions like ', 'follow', ' and ', 'collect', ' without having to sign any approval modals. This only works if the modules assigned to those actions are free and have no cost to them.']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Full code example']
['Free collect - ', 'https://github.com/lens-protocol/api-examples/blob/master/src/proxy-action/proxy-action-free-collect.ts']
['Free follow - ', 'https://github.com/lens-protocol/api-examples/blob/master/src/proxy-action/proxy-action-free-follow.ts']
['This returns a ', 'proxyActionId', " which is a new id linked to that event, this is important to keep as you need it to track the status of the action. You should track this behind the scenes so the user does not need to be blocked, requesting it every 1-2 minutes is enough. To them, it should look like it's done."]
["The API uses optimistic updates so when you click that button on the user it is complete and they inherit all the stuff instantly. You do not need to worry about optimistic UI caching on your end even though of course it's best practice. "]
['Once you got the proxy action id you should track its status to make sure it goes all the way through. ']
["You sometimes need to debug why your publication has not been snapshotted and not appearing when querying the API. This is a very common thing that a lot of developers find and it's because you have not followed the metadata standards set for the publication. This endpoint returns you the error reason so you can see why it failed."]
["In the example response, you can see it's saying this one failed because they put metadata version as 200 which isn't a supported version."]
['Metadata standards can be read here ', 'https://docs.lens.xyz/docs/metadata-standards']
['Updated', ' ', '3 months ago', ' ']
['This section is a bit more advanced low-level feature to make the clients faster with nonce management handled on the client itself.']
['full code repo ', 'https://github.com/lens-protocol/lens-api-examples']
['When using typed data signatures to send the transactions within the typed data you may have seen a ', 'nonce', '. This is used for security reasons to avoid anyone replaying signatures and a lot of other reasons which we will not dig into here, basically, this makes it secure. ']
['Each contract aka ', 'lensHub', ' and ', 'periphery', ' and all followers NFT contracts manage their own nonces so nonce 1 on ', 'lensHub', ' has no relation to the nonce on ', 'periphery', ' and so on. Now the main issue is that because ', 'evm', " state will only change when the transaction has been mined you have to wait for transaction 1 to be fully mined before you allow the user to send their next action (as it will get gas estimate issues as Ethereum source of truth is the current state and doesn't take into consideration the pending transactions). "]
['What does this mean:']
['you may be asking yeah ok but how do I get around that well in theory your client "knows" when someone has done a transaction so if the client managed the nonce itself it could allow. This leads me to talk about how you can get the information from the server to manage this yourself and avoid it when creating typed data. ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/who-collected-publication.ts']
['This query returns to you all the wallets which collected the publication.']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/hide-publication.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Once you publish something on-chain you can not remove it, that said if you have used a centralized link for storage you can remove it on the centralized side and the content will not be able to be loaded. If you are using IPFS you can unpin the content.']
['Since our indexer moves the content into its own storage our API will still show it.']
['These are all the points a proxy action can go through:']
['Updated', ' ', 'about 2 months ago', ' ']
['On anything which returns a ', 'Post', ' ', 'Comment', ' ', 'Mirror', ' or anything to do with a publication you have ability to filter on that metadata. ']
['Will use publications as an example but please note this is a filter on a lot more endpoints so make sure you look at the graphQL schema for the best visibility. ']
['This is the locale you which to filter on you can just pass in the region code or language code or both as the example above shows.']
['By default all flagged content warning publications is not brought back when querying but if you want to bring them back you can add this filter and it will include them. ']
['It must include at least one of the array. ']
['You can filter on the main content focus, if you do not supply anything for it then it bring back them all.']
['You can call this query to get the current nonces of the ', 'lensHub', ' and the ', 'periphery', '.']
["This will allow you to query the states on page load and then hold these states in memory. If the user then does an action let's say post and sends the transaction you can +1 onto the ", 'lensHubOnChainSigNonce', ' once you got the ', 'txHash', ', if rejected you do not need to do anything. Please note you will have some cases with MM where if the user acts very strange and clicks many actions and never approves or rejects the transactions they will have many approval modals to approve or reject with the same nonce meaning after the first approval the rest would fail. It is down to the client to handle that edge case if that means you do not allow them to do anything until that action has been approved or rejected or whatever UX you think is best. ']
["Also because users may be using other clients it's worth calling this query to compare states every now and again with your in-memory nonce to make sure they have not done something on another UI. We do have in the backlog ability to broadcast this through the client via WebSockets but it is currently not done. "]
['Once you got your nonce management for different actions mapped you can override the nonce on every typed data request using the ', 'options', ' which is a type of ', 'TypedDataOptions', ' that can be supplied when generating the typed data. Below is an example of me generating the typed data with an override nonce as my client is managing nonces to make the UX quick and fast. ']
['Ok, you got the client managing nonces and +1 on them when actions happen you also passed in the custom nonce on typed data calls the last part is understanding overriding the gas limits to avoid estimating gas. Within ethers when you do a contract call the parameter are the inputs then you have an option at the end that you can supply a ', 'gasLimit', " which means it won't check ", 'estimateGas', ' and allows you to send it. ']
['Updated', ' ', '3 months ago', ' ']
['Protocol stats are exposed to understand how busy everything is.']
['However, this mutation allows you to hide the publication you posted from our API\'s storage, but this DOES NOT do anything on-chain. This is a nice way to allow your users to "delete" publications and it will hide the content and media which was uploaded for it. The publication will still come back so UIs can render all the comments related to it and so it doesn\'t destroy the pointers, UIs can then design it how they wish but as said above the content and media will not be brought back for the UIs to render. If an application does not use our API and has their own subgraph or indexer they can still show this publication and read from the contentURI if that is not removed. ']
['You must own the publication to hide it, this is not the functionality to hide stuff that other people post this is to hide a publication you have done. ']
['returns a ', 'VoidScalar', ' which means no response is returned if you do look at the response data it will be data.hidePublication= null but you do not need to look at the response for anything which returns ', 'void', '. If it does not throw it is successful. ']
['Updated', ' ', '3 months ago', ' ']
['On a publication you can now add tags for discovery this allows you to filter on them.']
['It only needs to match 1 of the array passed in to bring it back. Remember publications can be tagged by many tags. ']
['It must match all tags supplied.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/get-publication.ts']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/get-publications.ts']
['This query returns to you a list of publications based on your request query. Remember posts, comments and mirrors are all publications. ']
['Did you know...']
['The publication id is not unique in the smart contract. It is a counter per each profile. So if @josh posts a publication, that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['Use the GraphQL schema...']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/feat/media_upload/src/media/create-attachment.ts']
['Media endpoints will allow the users to upload AUDIO and VIDEO directly to the API without using IPFS or a storage provider. It will create a copy of the file in our cache and streaming system before pinning it to the decentralised IPFS. All on-chain metadata will point to the decentralised IPFS CID, not our cache system.']
['first, you need to create the media type and then push the file to the signed URL. When the file is fully updated using the ', 'SignedURL', ' you then can create the post/comment with the Media on the metadata. We will explain in more detail below. ']
['Once the publication is mined, the Lens API will push the file to an IPFS storage making sure on-chain leverages the decentralised vision.']
['Only works with AUDIO and VIDEO.']
['Lens Protocol now supports the creation of gated content experiences so you can share your garden with just the people you wish. Gated content on Lens allows a trustless way to control content accessibility, as encryption and decryption happen on the client side. The Gated Publications feature uses LIT Protocol decentralized access control behind the scenes.']
['When you create a new Gated Publication, Lens users can now specify access conditions. Access controls mean that decrypting the publication content and media will only be available to (for example):']
['The possibility of creating gated experiences enables various kinds of interesting use-cases for gating and monetizing your content in the Lens Ecosystem, giving creators and publishers more control over how content is consumed.']
['The hidden metadata stays private end-to-end as it will be encrypted and decrypted only by the user who fulfills the access control condition. The only public piece of information is the ', 'encryptionKey', ' which cannot decrypt data by itself, but only when combined with a second key obtained by LIT Protocol, which is only possible when a user successfully satisfies the access conditions.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to mirror a publication from a profile on lens.']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['Publications are the posts, comments and mirrors that a profile posts. You can read more in-depth about what publications are ', 'here', '.']
['Make sure you read about the ', 'Metadata standards', ' we have set for all publications to conform to. ']
['Note: if a publication does not conform to these standards we will not index the publication. These are the guidelines set for the API; the protocol itself does not validate these guidelines. Building a standard allows compatibility for all kinds of projects, so we advise sticking to the standards.  If you found that there is anything missing, just get in touch. ']
['Our metadata standards can be extended so any suggestions are always welcome. ']
['Our publication resolver has these queries:']
['Updated', ' ', '9 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/protocol-stats/global-protocol-stats.ts']
['This query returns to you the global protocol stats of key metrics.']
["Let's look at the query options we can use here to get for different things. "]
['Updated', ' ', '3 months ago', ' ']
['Our protocol stats resolver have these queries:']
['Updated', ' ', '9 months ago', ' ']
['This query returns to you the publication information. Remember posts, comments and mirrors are all publications. ']
['Use the GraphQL schema...']
['One of the huge advantages of GraphQL is you have a schema that should explain how the schema should look at what properties exist in that. In these docs we explore code examples and explain key concepts but we will not explain each property that exists in the response for example, as the schema already does that!']
['Hot tip']
['If you do not know GraphQL that well remember things can be nullable if defined as so in the schema how GraphQL knows its nullable is without the ', '!', ' at the end here is an example:']
['Not nullable: ']
['ownedBy: EthereumAddress!']
['One of the huge advantages of GraphQL is that you have a schema that should explain how the schema should look at what properties exist in that. In these docs, we explore code examples and explain key concepts, but we will not explain each property that exists in the response for example, as the schema already does that!']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
["Let's look at the query options we can use here to get a lot of data for different things. "]
['Please note you can only supply one of these if you supply more than one the API will throw. We have to do it this way with optional parameters as GraphQL does not support unions on request yet.']
['Updated', ' ', 'about 2 months ago', ' ']
['Hot tip']
['If you want to add a Cover first need to be pushed to a IPFS service, we only take care of the Audio/Video attached on the item media.']
['Tip:']
['For upload the image need to be done with the http method PUT']
['Once you get the presignedUrl ', '(more info)', ' , you can upload the file to S3. ']
['Updated', ' ', 'about 1 month ago', ' ']
['To post or decrypt gated content, you will need the ', '@lens-protocol/sdk-gated', ' NPM package that you can find ', 'here', '. It works on both browser and node.js contexts, and allows you to encrypt metadata and upload them to your preferred storage, as well as decrypting any existing metadata as long as you satisfy the conditions.']
['First of all, you should know that when posting any gated content, what is actually gated is certain parts of its metadata, specifically the fields:']
["'content' , 'image', 'media', 'animation_url, 'external_url'"]
['This means that the posting process remains the same as with posting regular content, but in this case, the Lens API indexer picks up on some additional properties that will exist on any encrypted metadata generated by the ', '@lens-protocol/sdk-gated', ' package.']
['That said, from a client perspective, there are couple of things to take care of. First off, create an instance of the LensSDKGated class.']
['You can choose between ', 'Polygon', ', ', 'Mumbai', ' and ', 'MumbaiSandbox', ' environments.']
['You can optionally call the ', 'connect', ' method to initialize it with a given address and environment, otherwise it will get called automatically the first time you try to encrypt or decrypt content with the values it gets from your Provider.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.']
['Hot tip']
["It's super easy to enable modules within your publication using this typed data approach as the server lifts all the encoding and decoding of the modules for you. This allows you to just supply it as you would if you were using a web2 API."]
["Let's touch on this request so it's super clear."]
['You have to pass in a ', 'profileId', ' that is mandatory.']
['You have to pass in a ', 'publicationId ', ' that is mandatory.']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['Nullable:']
['ownedBy: EthereumAddress']
["It's always worth generating the TypeScript types for the schema if your application is TypeScript here is a reference to how you would do that - ", 'https://www.apollographql.com/blog/tooling/apollo-codegen/typescript-graphql-code-generator-generate-graphql-types/']
["Let's look into the request a little more:"]
['You can query the publication using the ', 'internalPublicationId', ' and return information about the publication.']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['There is a case where your user does a new post or comment or mirror and you send the transaction. At this point, you do not know the publication id without having to do some extra logic. This is the perfect time where you may want to query the publication by the ', 'txHash', ' to get the publication and update your internal UI cache or something else. ']
['Please note you can only supply one of these if you supply more than one the API will throw. We have to do it this way with optional parameters as GraphQL does not support unions on request yet.']
['To encrypt content, you need the ', 'encryptMetadata', ' method. Gets some metadata, your profileId (to make sure your encrypted data is accessible by you), the access conditions and a file upload handler with the following signature:']
['(encryptedMetadata: EncryptedMetadata): Promise<string>']
["This gives you the freedom to reuse your existing code in order to upload metadata to your preferred storage. It's the final argument the encrypted metadata call in the code example below. It's omitted from the code example for clarity. "]
['Keep in mind']
['Gated content only supports the Metadata V2 format, see ', 'here', '.']
['This will give you a ', 'contentURI', ' that you can then use on your regular posting flow. It also exposes the ', 'encryptedMetadata', ' object because you will need to supply the ', 'encryptionKey', ' on your upcoming call to ', 'createPostTypedData', ". Don't worry, this key is not enough to decrypt your data, it is used to query LIT Protocol, which upon verification that you do fulfill the access conditions, will then expose the actual decryption key.  "]
['Any content you post with the code above will have its metadata fields encrypted and replaced with placeholders. The actual content will only be available to people satisfying the access conditions, after calling ', 'decryptMetadata', ' on the ', '@lens-protocol/sdk-gated', ' package.']
['Given you have instantiated a ', 'LensGatedSDK', ' client with your wallet, and you have fetched some gated publication via the API, you can then simply:']
['Modules are quite complex, each module needs to be encoded in the correct way for the contracts not to throw. We tried to abstract any complex stuff out for you here and allow you to just pass in the params in web2 style. Mirrors can have their own reference modules as well separate from the mirrored publication. Please note to mirror from a profile it must pass the reference module check which is defined in ', 'canMirror', '.']
['A simple reference module that validates that comments or mirrors originate from a profile owned by a follower.']
['This is super easy to toggle just pass in the boolean in the ', 'followerOnlyReferenceModule', ' property and it turns it on and off for that publication. ']
['Usage:']
['This reference module allows you to set the degrees of separation in who can comment or mirror. If you do not know what degrees of separation you may have heard of the rule that with up to 6 links you can connect people together. With the protocol being open bots and spam is a things we want to handle and this tackles this. ']
['settings:']
['Full code example']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/set-default-profile.ts']
['This please you are burning your profile, all your content still lives on.']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/burn-profile.ts']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to set your profile picture for your profile on lens.']
['This request is protected by authentication']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to set your profile metadata for your profile on lens.']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
["As you attach an appId to the publications you post the number of publications you did on profile Y on app Z can be different from app H numbers, this allows you to query by sources to get the correct stats if you're building an app that only cares about the content of the app."]
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/get-profile.ts']
['Updated', ' ', '3 months ago', ' ']
['Here are the supported access condition types. Check out the remaining examples to see how they are used in action.']
['Remember!']
['When you supply a condition to the ', 'encryptMetadata', ' function, it takes a ', 'AccessConditionOutput', ' object as input, so make sure to wrap it in its corresponding type attribute as described in the following object:']
['Will evaluate to true if the decryptor owns an NFT from that collection. If ', 'tokenIds', ' are not provided, then owning ', 'any', ' NFT from the collection will satisfy the condition.  ']
['Evaluates to true if the decryptor has signed in from the provided EOA address.']
['commentsRestricted', " -  Boolean - if it's set to true the degree of separation is applied if false it is not which means anyone can comment."]
['mirrorsRestricted', " -  Boolean - if it's set to true the degree of separation is applied if false it is not which means anyone can mirror."]
['degreesOfSeparation', ' - Int - Max 4 degrees']
["This reference module is unknown and not type supported in the API. This means if you use this you have to encode and supply the data yourself to the API, the API will still allow you to use the unknown reference module but it won't validate it. Only use unknown reference modules if you can trust the reference module and know what you're doing. "]
['The API will support more modules which get whitelisted as they get approved.']
['as they do this doc will be updated alongside it.']
[' ', 'https://github.com/lens-protocol/api-examples/blob/master/src/publications/mirror.ts', ' shows you a live running example of how you would generate the signed typed data from the API and send it through the ', 'withSig', ' methods. ']
['If you are on mumbai anyone can use gasless but if your on polygon only whitelisted apps can currently use this']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/mutual-profile-follows.ts']
['This will return you mutual profiles based on the 2 profiles following. It will return to you all profiles that the profile you are viewing is followed by the profiles you follow.']
['Use the GraphQL schema...']
['One of the huge advantages of GraphQL is you have a schema that should explain how the schema should look at what properties exist in that. In these docs we explore code examples and explain key concepts but we will not explain each property that exists in the response for example, as the schema already does that!']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
['This action can be gasless']
['https://docs.lens.xyz/docs/broadcast-transaction', ') You can use the broadcast logic to send this gasless. Please note this is fully unlocked on mumbai but on polygon it is only whitelisted apps who can use it.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to set your default lens profile. ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to burn your lens profile. This please you are burning your profile, all your content still lives on.This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API, the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always-failing transaction, the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API, the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always-failing transaction, the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.']
['You can attach a normal link in the ', 'uri', ', this can be any image location you wish, our example shows the IPFS link. You can also attach the NFT data to link your profile NFT and prove ownership which you would have done using these docs ', 'NFT ownership challenge', '.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API, the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always-failing transaction, the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.']
['All the metadata of the profile is stored on-chain in a URL/IPFS link that points to the metadata just how NFTs work. This means updating profile details is a transaction. ']
['Get a single profile by ', 'id', ' or ', 'handle']
['Hot tip']
["If you do not know GraphQL that well remember things can be nullable if defined. In the schema how GraphQL knows it's nullable is without the ", '!', ' at the end here is an example:']
['Not nullable: ']
['ownedBy: EthereumAddress!']
['Nullable:']
['ownedBy: EthereumAddress']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/get-profiles.ts']
['The profile query has a few different ways you can query the profiles. Using the power of GraphQL is super flexible and allows the same endpoint to be used in many different cases.']
['Below is the overview of the entire interface but we dig into specific queries below.']
['Hot tip']
["If you do not know GraphQL that well remember things can be nullable if defined. In the schema how GraphQL knows it's nullable is without the ", '!', ' at the end here is an example:']
['Not nullable: ']
['Will evaluate to true if the decryptor satisfies some condition regarding the given ERC20 token.']
['Will evaluate to true if the decryptor owns that ProfileId']
['Will evaluate to true if you follow that ProfileId']
['Will evaluate to true if the person trying to decrypt the content owns a collected NFT of the given publication. Can take ', 'thisPublication=true', ' when encrypting metadata for people who will collect that specific pub. You can use either of these 2 properties, but not both of them.']
['These support up to 5 conditions and they cannot have nested boolean conditions right now.']
['You can view an example full stack application implementing Lens token-gating ', 'here', '.']
['You have 2 options when doing gasless you have ', 'broadcast', ' and also the ', 'dispatcher', '. The dispatcher supports a subset of methods that allows you to do actions without signing, these actions are protocol calls that can not drain funds from any wallet making them classed as safe actions, not all methods are supported by the dispatcher. Posting is one of those allowed dispatcher methods. You can set up a dispatcher for the user using ', 'https://docs.lens.xyz/docs/create-set-dispatcher-typed-data', ' and then broadcast that transaction which is described in that document. ']
['Full code example of gasless']
['https://github.com/lens-protocol/api-examples/blob/master/src/publications/mirror-gasless.ts']
['This doc ', 'https://docs.lens.xyz/docs/broadcast-transaction', ' explains how you would broadcast a transaction with the demo example in there. You basically use all of the examples in the GitHub code snippet but instead of calling the ', 'withSig', ' methods on the hub directly, you pass the signature into the broadcast call. This is all shown in the full code GitHub example above.']
['This takes in the same request as the ', 'withSig', ' method so nothing needs to change in that regard. You then can track the ', 'txId', ' to see what it is indexed. Look at the code examples for more low-level detail.']
['The profile id you are viewing']
['The profile id the user is looking from']
['Updated', ' ', '3 months ago', ' ']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API, the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always-failing transaction, the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', '3 months ago', ' ']
["Let's touch on this request so it's super clear. "]
['This is mandatory.']
['This can be any image link you wish.']
['Example using ', 'nftData', ' to set the profile picture:']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/set-profile-image-uri.ts', ' shows you a live running example of how you would generate the signed typed data from the API and send it through the ', 'withSig', ' methods. ']
['anything you put in ', 'attributes', ' will be extracted out of the metadata and put into the profile schema under ', 'attributes']
["Let's touch on this request so it's super clear. "]
['This is mandatory.']
['This is where your new metadata for your profile is stored']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/set-profile-metadata.ts', ' shows you a live running example of how you would generate the signed typed data from the API and send it through the ', 'withSig', ' methods. ']
['If you are on mumbai anyone can use gasless but if your on polygon only whitelisted apps can currently use this']
["It's always worth generating the TypeScript types for the schema if your application is TypeScript here is a reference to how you would do that - ", 'https://www.apollographql.com/blog/tooling/apollo-codegen/typescript-graphql-code-generator-generate-graphql-types/']
['Updated', ' ', '3 months ago', ' ']
['ownedBy: EthereumAddress!']
['Nullable:']
['ownedBy: EthereumAddress']
["It's always worth generating the TypeScript types for the schema if your application is TypeScript here is a reference to how you would do that - ", 'https://www.apollographql.com/blog/tooling/apollo-codegen/typescript-graphql-code-generator-generate-graphql-types/']
['You will see the paging result behavior repeated a lot in the API; this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
["Now you see the base query let's look at how we can use different request parameters to request profiles. "]
['Updated', ' ', '17 days ago', ' ']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', '3 months ago', ' ']
['Updated', ' ', '3 months ago', ' ']
['If you are on mumbai anyone can use gasless but if your on polygon only whitelisted apps can currently use this']
['You have 2 options when doing gasless you have ', 'broadcast', ' and also the ', 'dispatcher', '. The dispatcher supports a subset of methods that allows you to do actions without signing, these actions are protocol calls that can not drain funds from any wallet making them classed as safe actions, not all methods are supported by the dispatcher. Posting is one of those allowed dispatcher methods. You can set up a dispatcher for the user using ', 'https://docs.lens.xyz/docs/create-set-dispatcher-typed-data', ' and then broadcast that transaction which is described in that document. ']
['Full code example of gasless']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/set-profile-image-uri-gasless.ts']
['This doc ', 'https://docs.lens.xyz/docs/broadcast-transaction', ' explains how you would broadcast a transaction with the demo example in there. You basically use all of the examples in the GitHub code snippet but instead of calling the ', 'withSig', ' methods on the hub directly, you pass the signature into the broadcast call. This is all shown in the full code GitHub example above.']
['You have 2 options when doing gasless you have ', 'broadcast', ' and also the ', 'dispatcher', '. The dispatcher supports a subset of methods that allows you to do actions without signing, these actions are protocol calls that can not drain funds from any wallet making them classed as safe actions, not all methods are supported by the dispatcher. Posting is one of those allowed dispatcher methods. You can set up a dispatcher for the user using ', 'https://docs.lens.xyz/docs/create-set-dispatcher-typed-data', ' and then broadcast that transaction which is described in that document. ']
['Full code example of gasless']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/set-profile-metadata-gasless.ts']
['This doc ', 'https://docs.lens.xyz/docs/broadcast-transaction', ' explains how you would broadcast a transaction with the demo example in there. You basically use all of the examples in the GitHub code snippet but instead of calling the ', 'withSig', ' methods on the hub directly, you pass the signature into the broadcast call. This is all shown in the full code GitHub example above.']
['This takes in the same request as the ', 'withSig', ' method so nothing needs to change in that regard. You then can track the ', 'txId', ' to see what it is indexed. Look at the code examples for more low-level detail.']
['You can get the profiles by passing in an array of ', 'profileIds', ' please note if you try to pass in the ', 'ownedBy', ' or ', 'handles or ', 'whoMirroredPublicationId', 'alongside this you will get a', 'ValidationError` thrown. The same will happen if you pass in an empty array.']
['You can get the profiles by passing in an array of ', 'ownedBy', ' which is an array of ethereum addresses, please note if you try to pass in the ', 'profileIds', ' or ', 'handles or ', 'whoMirroredPublicationId', 'alongside this you will get a', 'ValidationError` thrown. The same will happen if you pass in an empty array.']
['You can get the profiles by passing in an array of ', 'handles', ', please note if you try to pass in the ', 'profileIds', ' or ', 'ownedByor ', 'whoMirroredPublicationId', 'alongside this you will get a', 'ValidationError` thrown. The same will happen if you pass in an empty array.']
['You can get the profiles of who mirrored a publication using the ', 'whoMirroredPublicationId', ', please note if you try to pass in the ', 'profileIds', ' or ', 'ownedBy or ', 'handles', 'alongside this you will get a', 'ValidationError` thrown. ']
['This takes in the same request as the ', 'withSig', ' method so nothing needs to change in that regard. You then can track the ', 'txId', ' to see what it is indexed. Look at the code examples for more low-level detail.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', '3 months ago', ' ']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', 'about 2 months ago', ' ']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. The backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all responses and also used in any request you which to do.']
['Updated', ' ', '3 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['This please you are burning your profile, all your content still lives on.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/get-default-profile.ts']
['This query returns to you the default profile for the wallet. A wallet can own many profiles but can set a default similar to how ens works with its resolvers. ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/create-profile.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Creating a profile on ', 'MAINNET', ' is only allowed by trusted whitelisted addresses for now. This endpoint can be used on ', 'TESTNET', ' to allow you to create profiles easily through your UI without worrying about the gas. This will only be exposed on the ', 'TESTNET', ' public API. This is great for when you building some cool stuff against the ', 'TESTNET', ' contracts. ']
['Updated', ' ', '3 months ago', ' ']
['This will show the queries exposed to get anything related to profiles back from the public API']
['Profiles are the accounts that create publications and are owned by wallets. You can read more in-depth about what profiles are ', 'here', '. ']
['Our profile resolver have these queries:']
['Updated', ' ', '7 months ago', ' ']
["Let's touch on this request so it's super clear. "]
['You must define the handle you wish to have for the profile which will be created. This is mandatory. ']
['You can pass in a ', 'profilePictureUri', ' which is a link to any kind of storage that points to an image. You can leave this out the request if you do not want to supply a default image for the profile. ']
['The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will default to a dynamic NFT which will show the last publication of your profile as the NFT image.']
['We do not enforce our standards on this metadata as it is purely to be showed on secondary marketplaces. We advise you follow opensea metadata spec for this ', 'https://docs.opensea.io/docs/metadata-standards']
['Defining the follow module is very easy with the schema we have created:']
['As the example above shows, you can leave this as null or not pass it in; if you do that it will point to the free follow module which basically means no modules are fired when someone follows you (free). We promote not passing it in the request if you do not want to set a follow module.']
['This can also be defined explicitly in the request by doing:']
['You do not want anyone to follow you; to set this up you can do:']
['You can charge a fee when someone follows you, to set this up when you create a profile you can do:']
['As you see above we have mapped the ', 'currency', ' we want to be paid in alongside the ', 'value', ' which should be passed in as the normal amount not shifted to the decimal places as our server does this for you. So if you want 1 WETH you would enter 1 as a value. The final property defined is the ', 'recipient', ' you want the funds to go to. ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/notifications/users-notifications.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Get notifications of actions occurring on Lens Protocol.']
['Full code example']
['You can update the follow module for your profile at any time, the resolver endpoints to generate the typed data for them are explained on the ', 'Create set follow module typed data', ' ']
['The API will support more modules which get whitelisted as they get approved.']
['as they do this doc will be updated alongside it.']
['When calling the ', 'createProfile()', ' function, the contract will add the ', '.test', ' or ', '.lens', ' extension to your handle. The best way to check all the profiles you have created is to send a ', 'getProfiles()', ' request filtered with ', 'ownedBy', ' and your account address as the value.']
['Updated', ' ', '3 months ago', ' ']
['The notifications bring back:']
['You can also filter by the exact notification type this can be passed into ', 'notificationTypes', ' request object to only bring back the notifications you care about. If you do not supply it then it brings them all back for you.']
['You will see the paging result behavior repeated a lot in the API.  This is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property.']
['Updated', ' ', '3 months ago', ' ']
['With any social platform, notifications are super important. Our API returns notifications on activity for your profile including collects, comment, new followers, and mirrors.']
['Our notification resolver has these queries:']
['Updated', ' ', '10 months ago', ' ']
['Full code example']
['This is an example of it hooked into the profile image']
['https://github.com/lens-protocol/api-examples/blob/master/src/profile/set-profile-image-uri-nft.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['This endpoint allows you to sign some text to prove you own an NFT. This is then used in setting your profile picture to an NFT image which then gets brought back on the ', 'Profile', ' entity.']
['This endpoint goes hand in hand with ', 'Set profile image URI', '.']
['Note: the challenge will last 20 minutes if it expires you will need to generate a new challenge.']
['Note when using this for Set profile image URI..']
['https://github.com/lens-protocol/api-examples/blob/master/src/nfts/get-users-nfts.ts']
['This query allows you to find what NFTs a user owns. It also allows you to query what they own by contract address to sees which specific NFTs a user owns in a given collection. We use Moralis API to get the NFT data. ']
['Below is the overview of the entire interface but we dig into specific queries below.']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
["Now you see the base query let's look at how we can use different request parameters to request different NFTs for the user."]
['To do this just set the ', 'ownerAddress', ' to the ethereum address you want to query for their NFTs.']
['To do this just set the ', 'ownerAddress', ' to the ethereum address you want to query for their NFTs and set the ', 'contractAddress', ' of the NFT you wish to filter it on.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
["As this is a generic API challenge for NFTs to make sure people do not get confused if you are using this to set a user's profile picture to the NFT then you must only pass in one NFT in the array. If you pass in more than one when you come to calling ", 'createSetProfileImageURITypedData', ' it will throw.']
["let's dig into the request a little more so its clear what is going on here"]
['The wallet address which owns the NFTs. ']
['Even though this is an authenticated endpoint you could own this NFT on a different wallet and want to sign it through your ledger etc. ']
['You can pass in an array of NFTs to verify ownership, but for now, the API does not allow you to just prove generic ownership to flex. The API only support setting your profile picture with your NFTs. A generic way of just proving ownership to flex NFT will be coming to the API soon. So for now most people will only be passing in 1 item here but the request was written to handle the other cases without a schema change. This endpoint was written to be used in a few places once we extend.']
['The contract address of the NFT you want to prove ownership of.']
['The tokenId you own of this NFT.']
['The chain id it is on.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/module/approved-allowance-of-modules.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Each ', 'Enabled modules currencies', ' needs to have approval greater than the amount of the collect module. If it is not then an API request will throw an error as the module will not be able to move funds on your behalf. ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/module/approve-module.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['We have seen the NFT space explode over the past year and expect many developers to integrate NFTs into their applications. We have NFT lookups exposed for you so you can query NFTs on both Polygon and Ethereum, with more networks being supported in the future.']
['Did you know..']
['You can set NFT images as profile pictures and the server will track if they still own it every few hours. If they do not it will be removed from their profile picture.']
['Our NFT resolver has these queries:']
['Updated', ' ', '10 months ago', ' ']
['https://github.com/lens-protocol/api-examples/blob/master/src/module/enabled-modules.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['This query returns to you all the modules that the server knows about and information about those modules.']
['Updated', ' ', 'about 2 months ago', ' ']
['This query returns you the amount approved that the modules can move on your behalf for the array of currencies you supply.']
['Updated', ' ', '3 months ago', ' ']
['The indexer resolver holds states about what the API knows about. Nothing is broadcasted on our API until it has been minted and indexed by us. Our indexer runs on every block so is very fast and broadcasting this data to the API once indexed. ']
['Our indexer resolver contains:']
['Updated', ' ', '10 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/indexer/has-transaction-been-indexed.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Normally when you broadcast transactions to the blockchain you wait for the receipt to know the transaction has been completed fully. The transaction is in a pending state until you have a receipt. If you use ', 'ethers.js', ' you normally use their method to wait to get the receipt. ']
["As this is slightly different your source of truth is actually the API's indexer and database. So this method allows you to swap out the wait method from ", 'ethers.js', ' and use this API query as a source of truth for when it is complete. ']
['The indexer tracks all transaction hashes to allow you to easily query to work out if the indexer has now broadcasted it. Please note there is a 2 stage process when you do a publication:']
['If your using gasless']
['This query encodes the ', 'allowance', ' ERC-20 data for you for the module. This allows you to just call this without any context of the modules contracts or how to construct the approval and it will return you the partial transaction you just need to give it a gas price, estimate the gas and send it. ']
["Let's dig in the request to make sure its super clear"]
['This is the module currency you wish to approve for the user']
['This is the value you want the user to approve this module with. It can be a high amount if you do not want them to keep approving it, but that tends to be up to the user to pick. It should be supplied in the normal formatted UI amount so if you want to approve 10 ETH you pass in "10" not the wei equivalent. It is a string number because of the overflows a JS number can have. ']
['This is the collect module you wish to approve. You can just pass in the enum value and the server will map the rest for you. This can not be used alongside the other modules it should only be supplied by itself. ']
['This is the follow module you wish to approve. You can just pass in the enum value and the server will map the rest for you. This can not be used alongside the other modules it should only be supplied by itself. ']
['This is the reference module you wish to approve. You can just pass in the enum value and the server will map the rest for you. This can not be used alongside the other modules it should only be supplied by itself. ']
['Updated', ' ', '3 months ago', ' ']
['Modules are an integral part of the Lens Protocol: they allow profile owners to include unique, custom functionality on follow, collect and reference. You can read more about modules ', 'here', ' and what they do. ']
['The module resolver have these queries:']
['Updated', ' ', '10 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/module/enabled-modules-currencies.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Modules currencies are whitelisted tokens that can be used as the currency for charged modules. All module currencies must be whitelisted by the governance, if you try to use a none whitelisted currency when setting the module it will throw an error. ']
[' This query returns to you all the enabled module currencies']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/module/collect.ts']
['This action can be gasless']
['https://docs.lens.xyz/docs/broadcast-transaction', ') You can use the broadcast logic to send this gasless. Please note this is fully unlocked on mumbai but on polygon it is only whitelisted apps who can use it.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to collect a publication on Lens.']
['Please note each ', 'Enabled modules currencies', ' need to have a ', 'Approved allowance of modules', ' greater than the amount the collect module is. If it is not then an API request will throw an error as the module will not be able to move funds on your behalf. ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['When using gasless you must use the ', 'txId', ' over the ', 'txHash', ' as the gasless would bump up the transaction if the gas prices move meaning a new ', 'txHash', ' will be generated.']
['you may see that the request takes in a nullable ', 'txHash', ' or a nullable ', 'txId', ' if you are not using the server relay ', 'txHash', ' you should always use the ', 'txHash', ' when doing this query. Please note if the user upgrades the gas price the ', 'txHash', ' changes so your client should handle that on those edge cases to avoid being stuck in a loop until that ', 'txHash', ' is dropped (sometimes can take a long time).']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/health/ping.ts']
['This returns if the API is online.']
['Updated', ' ', '3 months ago', ' ']
['The health status of our API is important to know the state of the API at a given time.']
['Our health resolver contains:']
['Updated', ' ', '10 months ago', ' ']
["You need to know if the logged-in user is being followed back by the owner of the profile it's viewing, to do this you need to look at the ", 'isFollowing', ' property on the profile response. This is shown in the examples when fetching back a profile. In the ', 'isFollowing', ' field resolver you can pass in a ', 'profileId', ' you wish to know if the owner of this profile is following, most apps would use the logged in users selected profile they are browsing on.']
["please note the example below doesn't pick all the content out of the profile it just shows you the field used to get that back."]
['The profile id passed in for ', 'isFollowing', ' can pass in as a variable easily enough as well. You can imagine passing the logged-in users profile they are browsing on to see if you should render a ', 'follows back', ' label. This can be hooked in like this for every query which returns a profile type.']
['Updated', ' ', '7 months ago', ' ']
['Full code example']
['You can check current list ', 'here']
['WMATIC -> 0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889']
['Updated', ' ', 'about 2 months ago', ' ']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions. ']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', '3 months ago', ' ']
["You need to know if the logged-in user is following the profile it's viewing, to do this you need to look at the ", 'isFollowingByMe', ' property on the profile response. This is shown in the examples when fetching back a profile. It will always be false if calling when not logged in but when passing in the auth header it will work out if that wallet has is following the profile.']
["please note the example below doesn't pick all the content out of the profile it just shows you the field used to get that back."]
['Updated', ' ', '7 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/follower-nft-owned-token-ids.ts']
['This query returns the follower NFT for a profile token ids that the wallet address owns. Remember a wallet can follow a profile as many times as they wish. ']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/followers.ts']
['This query returns the wallet addresses which are following a profile']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property.']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/following.ts']
['This query returns all the profiles an Ethereum address is following']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property.']
['Updated', ' ', '3 months ago', ' ']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/does-follow.ts']
['This query returns to you if the Ethereum address follows a profile. It allows you to do a bulk request.']
['We highly advise using ', 'Is followed by me', ' and ', 'Is following', ' as it solves most of the cases when you want to use this. ']
['Updated', ' ', '3 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/pending-approval-follows.ts']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/set-follow-nft.ts']
['This action can be gasless']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/set-follow-module.ts']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['To get around the issues with people being able to spam other people will a follower NFT we have brought in approval follows. Look at this situation:']
['You can see from the above how this could be a huge issue and with spam already a major thing on cheap transaction chains we do see this being a problem from day 1. ']
['To solve this we have a contract call called toggleFollow allowing you to move these from pending approvals to approved follows. ']
['This query returns all the pending approval follow NFT you have been sent and a way to show the user these so they can approve them.']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property.']
['Updated', ' ', '3 months ago', ' ']
['https://docs.lens.xyz/docs/broadcast-transaction', ') You can use the broadcast logic to send this gasless. Please note this is fully unlocked on mumbai but on polygon it is only whitelisted apps who can use it.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to set your follow NFT for your profile on lens. This is what your users will mint and see on secondary marketplaces and in their wallets as the follower NFT.']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['This action can be gasless']
['https://docs.lens.xyz/docs/broadcast-transaction', ') You can use the broadcast logic to send this gasless. Please note this is fully unlocked on mumbai but on polygon it is only whitelisted apps who can use it.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to set your follow module for your profile on lens.']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions. ']
["Let's touch on this request so it's super clear. "]
['This is mandatory ']
['The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will create a super cool changing NFT which will show the last publication of your profile as the NFT which looks awesome! This means people do not have to worry about writing this logic but still have the ability to customize it for their followers.']
['We do not enforce our standards on this metadata as it is purely to be showed on secondary marketplaces. We advise you follow opensea metadata spec for this ', 'https://docs.opensea.io/docs/metadata-standards']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', 'about 2 months ago', ' ']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions.  ']
["Let's touch on this request so it's super clear. "]
['This is mandatory ']
['Defining the follow module is very easy with the schema we have created:']
['You can unset your follow module back to nothing by using the ', 'freeFollowModule']
['You can charge to have someone follow you; to set this up you can do:']
['As you see above we have mapped the ', 'currency', ' we want to be paid in alongside the ', 'value', ' which should be passed in as the normal amount not shifted to the decimal places as our server does this for you. So if you want 1 WETH you would enter 1 as a value. The final property defined is the ', 'recipient', ' you want the funds to go to. ']
['You do not want anyone to follow you; to set this up you can do:']
['You only want people with profiles to be able to follow you and only once on that profile (avoiding spam); to set this up you can do:']
['The API will support more modules which get whitelisted as they get approved.']
['as they do this doc will be updated alongside it.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', 'about 2 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['This will show the queries exposed to get anything related to profiles back from the public API']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/follow.ts']
['This action can be gasless']
['Follow resolver contains anything relating with the profiles follow actions. Every time someone follows it mints an NFT, you can read more in-depth about how follows work ', 'here', '. ']
['The follow resolver have these queries:']
['Updated', ' ', '10 months ago', ' ']
['https://docs.lens.xyz/docs/broadcast-transaction', ') You can use the broadcast logic to send this gasless. Please note this is fully unlocked on mumbai but on polygon it is only whitelisted apps who can use it.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to follow profiles on lens.']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions. ']
['You can follow many people in a single contract call so the API interface is designed around that as well.']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/follow/unfollow.ts']
['This action can be gasless']
['https://docs.lens.xyz/docs/broadcast-transaction', ') You can use the broadcast logic to send this gasless. Please note this is fully unlocked on mumbai but on polygon it is only whitelisted apps who can use it.']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to unfollow someone on lens.']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/explore/explore-publications.ts']
['This query returns a list of publications based on the top collected or top comments. It randomizes it so it is never the same content you see twice similar to how Instagram works when you refresh their explore section. ']
['For now, this uses basic explore logic on basic data the protocol has. We will be greatly increasing this when we start doing AI on the explore feeds and endpoints. If you integrate this API into your application you will be inheriting all of these improvements with no code changes. ']
['The explore resolver API returns content which is trending on the Lens protocol. Over time we shall add more features into this resolver.']
['Our explore resolver contains:']
['Updated', ' ', '7 months ago', ' ']
["Let's touch on this request so it's super clear. "]
['You have to pass in a ', 'profile', ' that is mandatory (this is the ', 'profileId', ').']
['If you are following someone who has a follow module defined you must pass in the properties to redeem it. We make you pass in the properties from the client-side because if we read it from the server each time someone could front-run the request and make you sign something which your client was not seeing at the time of generating the signature. Follow modules can be changed at any time by the profile. If no follow module is setup for this profile you do not need to pass anything in.']
['Defining the follow module to be redeemed is very easy with the schema we have created:']
['If the person has no follow module setup you do not need to pass anything into the follow module']
['The person you want to follow requires you to have a profile to follow him. You have to pass your ', 'profileId', ' into the request. That profile can only follow them once which stops spam.']
['The person your following has a fee follow module setup']
['As you see above we have mapped the ', 'currency', ' the profile wants to be paid in alongside the ', 'value', ' which should be passed in as the normal amount not shifted to the decimal places as our server does this for you. So if the profile cost to follow is 1 WETH you would enter 1 as a value.']
['You know all this information about a profile as the follow module is attached to the ', 'Profile', ' schema itself ', 'Get profiles', '. ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions. ']
['If you are not following this profile it will throw a validation error and not generate the types.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Did you know...']
['The publication id is not unique in the smart contract its a counter per each profile. So if @josh posts a publication that will be publication 1 for his profile and then if @josh2 posts a publication that will be publication 1 for his profile. Our backend generates what we call an ', 'InternalPublicationId', ' which is built up from ', '{profileId}-{publicationId}', ' creating a unique ID that can be queried against our database. You will see that ', 'InternalPublicationId', ' is used on all our responses and also used in any request you which to do.']
['Use the GraphQL schema...']
['One of the huge advantages of GraphQL is you have a schema that should explain how the request and response schema should look at what properties exist in that. In these docs we explore code examples and explain key concepts but we will not explain each property that exists in the response for example, as the schema already does that!']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
["Let's look at the query options we can use here to get a lot of data for different things. "]
['Updated', ' ', 'about 2 months ago', ' ']
['The API will support more modules which get whitelisted as they get approved.']
['as they do this doc will be updated alongside it.']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['Updated', ' ', 'about 2 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/explore/explore-profiles.ts']
['This query returns a list of profiles based on the profile sort criteria you pass in.']
['Use the GraphQL schema...']
['Updated', ' ', 'about 2 months ago', ' ']
['One of the huge advantages of GraphQL is you have a schema that should explain how the request and response schema should look at what properties exist in that. In these docs we explore code examples and explain key concepts but we will not explain each property that exists in the response for example, as the schema already does that!']
['The example below uses ', 'MOST_FOLLOWERS', ' sort criteria but you have many other options which are explained below.']
['You will see the paging result behavior repeated a lot in the API, this is to allow you to fetch a certain amount and then page it for the most optimal request speed. Every time something is wrapped in a paging result you will always get returned a ', 'pageInfo', ' which holds the cursors for the previous and next alongside the total count which exists in the database. These cursors are just pointers for the server to get to the next result and do not need to be understood by your client or server. If you ever want to then page to the next result you can pass these previous and next cursor in the request cursor property. ']
["Let's look at the query options we can use here to get a lot of data for different things. "]
['You can filter the profiles using any of the below:']
['Updated', ' ', 'about 2 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/authentication/login.ts']
['To login it takes two server actions: the first is to generate a challenge from the server, and the second is to sign that challenge with your Ethereum wallet and send the signature to our server to generate a valid JWT access token, and refresh token. ']
["Authentication is used on the API on some API endpoints. In the docs, we notify you when you're looking at an endpoint that needs authentication. We use JWT tokens as our authentication layer and use the user's Ethereum wallet to verify ownership. This token can also be used in your own server-side application if you wish as you can use the ", 'Verify JWT', ' endpoint to make sure the JWT token is valid on your server itself, this is explained in greater detail below.']
['Our authentication resolver contains:']
['Updated', ' ', '10 months ago', ' ']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/authentication/refresh.ts']
['Your ', 'accessToken', ' expires every 30 minutes this means you have to refresh it with the ', 'refreshToken', ' to get a new access token. It is up to your client to make sure that you refresh it before it expires.']
['hint: use ', 'https://jwt.io/', ' to decode your JWT token, when you do in the payload section you will see some claims showing. ', 'exp', ' is the unix timestamp for when the token will expiry.']
['Updated', ' ', 'about 2 months ago', ' ']
['Please note you can use broadcast freely on mumbai but if you want to use it on polygon you need to be whitelisted.']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/broadcast/broadcast-follow-example.ts']
['Another note you should only call ', 'broadcast', " if you are using the typed data logic. If you are using the dispatcher you don't need to broadcast it. If the user does not have a dispatcher on this is the way you can relay the transaction allowing the user not to pay gas."]
['if you look at the schema you will see a broadcast mutation:']
['This is the ID that is given back to you when you call any of the typed data calls example:']
['Full code example']
['https://github.com/lens-protocol/api-examples/blob/master/src/authentication/verify.ts']
['You may wish to use the same authentication on your server-side to save you having to do authentication yourself as the claims hold the Ethereum address in it; the issue you would face is verifying that token is actually signed by the server and the user or if it has just been generated and is not secure. This endpoint solves this for you.']
['To get a JWT token, you must first request a challenge from the server, which will return you some text to sign with the wallet to prove ownership. Please note the challenge will only last 5 minutes before it expires, if it expires you must generate a new challenge. Once you have used the challenge to generate a JWT token it will not work again.  ']
['Once you get the challenge text from the server you need to sign the challenge with your ethereum wallet and then pass that signature to the ', 'authentication', ' endpoint, this will generate you an ', 'accountToken', ' and a ', 'refreshToken', '. ']
['Updated', ' ', 'about 2 months ago', ' ']
['Blockchain technology introduced many drawbacks like wallet popups, seed phrases, passwords, funds, and multi-network (blockchain) dynamics. These are fundamental for securing cryptographic transactions but present many UX challenges. So, are we doomed, or should we be optimistic?']
["In blockchain terms, Optimistic means that we assume the transaction will come through so we don't need to wait for validators to reach a consensus. This wouldn't be acceptable for financial transactions because of the double spending problem but can be helpful for social media interactions."]
['Social media is about great frontend experiences so having wallet prompts for every share or follow is not ideal. The challenge is that being optimistic in a front-end experience is possible but still, every action must be approved by the user wallet.']
['https://docs.lens.xyz/docs/create-post-typed-data']
[]
['please note you will be given an ', 'expiresAt', ' date if you try to send the broadcast after that has expired it will be rejected. It is worth checking that for edge cases if someone takes a long time accepting the approval modal.']
['This is the signature without it being split so after your call ', 'ethers _signTypedData', ' as you must do now if using the typed data methods instead of calling ethers ', 'utils.splitSignature', ' you just pass in the full hex string of the signature.']
['The response will either give you back a RelayerResult which holds the ', 'txHash', ' and a ', 'txId', ' (this is explained more below) or a RelayError which will give you a reason:']
['If you see a rejection it is worth allowing them to pay for it themselves so if the error happens use the normal ', 'withSig', ' methods so you can handle gasless and if gasless is ever turned off without your code-breaking. ', 'REJECTED', ' can mean they have used the max allowance in the hour.']
['URQL', ' is a lighter library than the apollo client but allows you to query the API all the same. ']
['open the terminal in your client and run:']
['apollo client', ' is an awesome library that supports all web frameworks like angular, react, and vue but it also supports mobile clients like IOS, Android, and react-native. It is super easy to use.']
['open the terminal in your client and run:']
['You can create the ', 'ApolloClient', ' which you then use for all public API queries like:']
['Then you can use it to query the Lens public API:']
['A lot of queries need variables to be passed in, this is super easy by using the ', 'variables', ' argument in the query']
['While we use queries to fetch data, we use mutations to modify server-side data.']
['Updated', ' ', 'about 2 months ago', ' ']
['To solve this issue, we created the ', ' Dispatcher', '. Basically, it is an intermediate wallet with funds that act as the signer for every transaction. We only have to delegate signing privileges to this dispatcher wallet which operates hidden in the backend. This combined with an optimistic UI creates a seamless experience identical to what we are used to today.']
[]
[]
['Security']
['Dispatcher only works for post, comment, mirror, set profile metadata and set profile image.']
['Post - ', 'https://docs.lens.xyz/docs/create-post-typed-data#gasless']
['Comment - ', 'https://docs.lens.xyz/docs/create-comment-typed-data#gasless']
['This is the interface all Lens Protocol Compatible Collect modules must implement.']
['function initializePublicationCollectModule(uint256 profileId, uint256 pubId, bytes calldata data) external returns (bytes memory);']
['This function initializes data for a given publication being published. This can only be called by the LensHub contract.']
['This is the interface all Lens Protocol Compatible Reference modules must implement.']
['function initializeReferenceModule(uint256 profileId, uint256 pubId, bytes calldata data) external returns (bytes memory);']
['This function initializes data for a given publication being published. This can only be called by the hub.']
["It returns an ABI encoded byte array encapsulating the execution's state changes. This will be emitted by the hub alongside the collect module's address and consumed by the front ends."]
['function processComment(uint256 profileId, uint256 profileIdPointed, uint256 pubIdPointed) external;']
['You need to use ', 'https://docs.lens.xyz/docs/has-transaction-been-indexed', " endpoint to know when it's been indexed. This should be your source of truth and the only thing you call to watch for it to be successful. The main difference between what you should do with this call when using the relay and what you should call when not using the relay is instead of passing in the ", 'txHash', ' into the ', 'hasTxHashBeenIndexed', ' pass in the ', 'txId', ' returned in ', 'RelayerResult', " this is because our relay will speed up gas on the transactions if the gas prices move or if it's taking too long to be picked up, this, of course, generates a new ", 'txHash', ' and the old one would be dropped. So this is to make sure your client is never stuck in a loop forever. Also because we have to do an extra HTTP call here to find out the status from the transaction id when using txId it will be longer response times than using ', 'txHash', ' so we recommend only calling it once every 1 second.']
['Updated', ' ', 'about 2 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can create the ', 'URQLClient', ' which you then use for all public API queries like:']
['Then you can use it to query the Lens public API:']
['Updated', ' ', 'about 2 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Updated', ' ', 'about 2 months ago', ' ']
['Mirror - ', 'https://docs.lens.xyz/docs/create-mirror-typed-data#gasless']
['Profile metadata - ', 'https://docs.lens.xyz/docs/create-set-update-profile-metadata-typed-data#gasless']
['Profile image - ', 'https://docs.lens.xyz/docs/create-set-profile-image-uri-typed-data#gasless']
['You can use the ', 'withSig', ' methods and go through the ', 'broadcast', ' logic to keep transactions gasless but that still requires a signature. The dispatcher is an opt-in step so you can check if a profile has a dispatcher on by doing:']
['If the ', 'canUseRelay', ' is true this means they can use the built-in dispatcher on the API. Remember profiles could have mapped to another dispatcher which is not the lens API one so if it is false you can not do dispatcher transactions through the API. You would have to prompt the user to move over to ours which is described below. Also, note that dispatcher can not be set at all if so it will be ', 'dispatcher: null']
["As a dispatcher can only use a subset of methods this doesn't mean you can not be gasless for everything. Any ", 'withSig', ' methods can go through the relay. On each document, if that logic can go through the ', 'broadcast', ' it will state it to make it very clear for you.']
['Full code example']
['Disable - ', 'https://github.com/lens-protocol/api-examples/blob/master/src/dispatcher/disable-dispatcher.ts']
["It returns an ABI encoded byte array encapsulating the execution's state changes. This will be emitted by the hub alongside the collect modules address and should be consumed by the front ends."]
['function processCollect(uint256 referrerProfileId, address collector, uint256 profileId, uint256 pubId, bytes calldata data) external;']
['This function processes a collect action for a given publication; this can only be called by the Lens Hub contract.']
['The ', 'Revert Collect Module', ' causes all collect actions on a given post to fail, thus making the post uncollectible.']
['The ', 'Free Collect Module', ' allows any profile to collect the publication this module is attached to.']
['The ', 'Fee Collect Module', ' allows for any follower to collect the associated publication provided they pay a fee set by the poster. This fee must be denominated in a whitelisted currency. Additionally, the poster can specify a portion of the fee that goes to a user who mirrors this publication, should the collect action be executed via their mirrored post.']
['Lastly, governance can add a treasury fee, which will send a portion of the collect fee to a designated treasury address.']
['This function processes a comment action referencing a given publication. This function can only be called by the LensHub contract.']
['function processMirror(uint256 profileId, uint256 profileIdPointed, uint256 pubIdPointed) external;']
['This function processes a mirror action referencing a given publication. This function can only be called by the LensHub contract.']
['The ', 'Follower Only Reference Module', ' ensures that only a profile is only allowed to mirror or comment on content if that wallet contains the FollowNFT of the profile that posted the comment they are mirroring or commenting on.']
['Updated', ' ', '5 months ago', ' ']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['This is the interface all Lens Protocol Compatible Follow modules must implement.']
['function initializeFollowModule(uint256 profileId, bytes calldata data) external;']
['This function initializes the follow module for a given Lens profile. The hub contract can only call this.']
['View functions in the LensHub.sol contract']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['Enable - ', 'https://github.com/lens-protocol/api-examples/blob/master/src/dispatcher/enable-dispatcher.ts']
['This API call allows you to get the typed data to then call the ', 'withSig', ' method to set a dispatcher for your Lens profile.']
['Dispatcher allows another address to post, comment, mirror, set follow module and change the profile picture on behalf of you using their wallet']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['Typed data is a way to try to show the users what they are signing in a more readable format. You can read more about it ', 'here', '.']
['Constructing that type of data is normally difficult. On the type data, you also need to get the nonce, deadline, contract version, contract address, chain id, and the name of the contract for the signature to be able to be signed and verified. ']
['The ', 'Limited Fee Collect Module', ' allows for any follower to collect the associated publication, provided they pay a fee, up to a specific limit of mints. As with the Fee Collect Module, the fee must be denominated in a whitelisted currency, a mirror fee can be specified, and governance can direct a treasury fee to a designated treasury address.']
['The ', 'Timed Fee Collect Module', ' allows for any follower to collect the associated publication, provided they pay a fee, up to a specific time limit. The present whitelisted Timed Fee Collect module only has a 24-hour time limit to reduce gas usage and optimize efficiency. ']
['As with the Fee Collect Module, the fee must be denominated in a whitelisted currency, a referral fee can be specified, and governance can direct a treasury fee to a designated treasury address.']
['Note, if uninitialized, no fee will be specified. Only the time limit will be checked, providing functionality similar to the Free Collect Module with a time limit for mint added.']
['The ', 'Limited Timed Fee Collect Module', ' allows for any follower to collect the associate publication, provided they pay a fee, up to a specific time limit and mint cap. It is essentially a combination of the Timed Fee Collect Module and the Limited Fee Collect Module.']
['As with the base Fee Collect Module, the fee must be denominated in a whitelisted currency. A referral fee can be specified, and governance can direct a treasury fee to a designated treasury address.']
['function processFollow(address follower, uint256 profileId, bytes calldata data) external;']
['This function processes a given follow; this can only be called from the LensHub contract.']
['followModuleTransferHook(uint256 profileId, address from, address to, uint256 followNFTTokenId) external;']
['This is a transfer hook that is called upon follow NFT transfer in ', 'beforeTokenTransfer.', ' This can only be called from the LensHub contract. ']
["NOTE: Special care needs to be taken here: It is possible that follow NFTs were issued before this module was initialized if the profile's follow module was previously different. This transfer hook should consider this, especially when the module holds state associated with individual follow NFTs."]
['function validateFollow(uint256 profileId, address follower, uint256 followNFTTokenId) external view;']
['This is a helper function that could be used in conjunction with specific collect modules.']
['This is the core entry point contract for essentially all interactions with the Lens Protocol. It is an upgradeable contract via the standard OpenZeppelin ', 'TransparentUpgradeabilityProxy.', ' This document elaborates on the functions of the implementation, assuming they are called via the proxy. Functions that take a struct as the sole input parameter will display struct members in the parameter table.']
['Note that as a design choice, all NFTs ', 'should not', ' mint a token with ', 'tokenId == 0', ' in any circumstance, as this is equivalent to an uninitialized variable.  Furthermore, ERC721 standard functions have been omitted from this document.']
['Updated', ' ', '11 months ago', ' ']
['function isFollowModuleWhitelisted(address followModule) external view returns (bool);']
['Returns']
['This function returns whether a follow module is whitelisted.']
['It should...']
['function isReferenceModuleWhitelisted(address referenceModule) external view returns (bool);']
['Returns']
['This function returns whether a reference module is whitelisted.']
['It should...']
['When using this API the server checks every detail before it generates the typed data. For example: if you try to create typed data on an always failing transaction the server will throw an error in a human-readable form. This is great for debugging but also saves issues with users sending always failing transactions or a mismatch of a bad request.']
['We will show you the typed data approach using ethers and the API side by side. Keep in mind that with the typed data approach you use the ', 'withSig', ' methods which can be called by you with your signature or with that signature any relay could call it for you on your behalf allowing gasless transactions. ']
["Let's touch on this request so it's super clear."]
['You must pass in a ', 'profileId', ' that is mandatory.']
['You can pass in the ', 'dispatcher', ' as per the above to set a dispatcher.']
['You can remove the dispatcher by setting ', 'enabled: false', '. ']
['Example in the request as below:']
['You may not want to go down the typed data with the signature route and just send the transaction directly from the client to the blockchain without any API call to map the data for you. You will need to do the encoding and validation yourself if you go down that approach. This is out of scope for the API documentation as would have been explained and showed how to do it in the contract docs. This tries to advise the same practice as what ', 'seaport', ' on OpenSea are doing alongside a lot of other projects which tries to improve the visibility of what the user is signing.']
['State changing functions in the LensHub.sol contract']
['All "', 'withSig', '" meta-transaction functions have been omitted from this document, as they allow for the same functionality as their standard counterparts, only via EIP-712 meta-transactions. Also, the requirements in this specification are not presented in any order pertaining to security.']
['function initialize(string calldata name, string calldata symbol, address newGovernance) external;.']
['Additionally, as with the Timed Fee Collect Module, no fee will be specified if uninitialized. Only the time limit and mint cap will be checked, providing functionality similar to the Free Collect Module with a time limit for mint and mint cap added.']
['Updated', ' ', '5 months ago', ' ']
['NOTE: This function IS meant to replace a check on follower NFT ownership.']
['NOTE: It is assumed that not all collect modules are aware of the token ID to pass. In these cases, this should receive a ', 'followNFTTokenId', ' of 0, which is impossible regardless.']
['One example of a use case for this would be a subscription-based following system:', '\n1. The collect module:', '\n- Decodes a follower NFT token ID from user-passed data.', '\n- Fetches the follow module from the hub.', '\n- Calls ', 'validateFollow', ' passing the profile ID, follower & follower token ID.', '\n2. The follow module:', '\n- Validates the subscription status for that given NFT, reverting on an invalid subscription.']
['The ', 'Approval Follow Module', ' only allows addresses that are approved for a profile by the profile owner to follow. Users can use the ', 'approve()', ' function to add/remove addresses from the Approved Array. the ', 'isApproved()', ' or ', 'isApprovedArray()', ' functions allow applications to check which address(es) are approved by a given user.']
['The ', 'Fee Follow Module', ' only allows addresses to follow a given profile, so long as they pay a fee specified by the profile owner. Users can set the currency and amount required to be paid so long as the ', 'currency', ' has been whitelisted by governance. Additionally, governance can adjust the ', 'treasuryFee', ' variable to direct some of the follow fees to a specified treasury address.']
['function isCollectModuleWhitelisted(address collectModule) external view returns (bool);']
['Returns']
['This function returns whether a collect module is whitelisted.']
['It should...']
['function getGovernance() external view returns (address);']
['Returns']
['This function returns the current governance address.']
['It should...']
['Our dispatcher resolver contains:']
['Updated', ' ', 'about 2 months ago', ' ']
['This function initializes the proxy contract. ']
['It should...']
['function setGovernance(address newGovernance) external;']
['This function sets the governance address. Note that we do not implement a built-in timelock or a 2-step governance change because it is assumed that the governance role will implement the necessary mechanisms.']
['It should...']
['function setEmergencyAdmin(address newEmergencyAdmin) external;']
['This function sets the emergency admin.']
['Updated', ' ', '5 months ago', ' ']
['function getDispatcher(uint256 profileId) external view returns (address);']
['Returns']
['This function returns the dispatcher for the given profile if any.']
['It should...']
['function getPubCount(uint256 profileId) external view returns (uint256);']
['Returns']
['This function returns the publication count for the given profile.']
['It should...']
['It should...']
['function setState(DataTypes.ProtocolState state) external;']
['This function sets the current protocol state, between ', 'ProtocolState.Paused', ', ', 'ProtocolState.PublishingPaused', ' and ', 'ProtocolState.Unpaused', '.']
['It should...']
['function whitelistProfileCreator(address profileCreator, bool whitelist) external']
['This function sets whether a profile creator is whitelist, allowing or disallowing profile creation from that address.']
['It should...']
['function whitelistFollowModule(address followModule, bool whitelist) external']
['function getFollowNFT(uint256 profileId) external view returns (address);']
['Returns']
['This function returns the follow NFT for the given profile, if any.']
['It should...']
['function getCollectNFT(uint256 profileId, uint256 pubId) external view returns (address);']
['Returns']
['This function sets whether a follow module is whitelisted, allowing or disallowing profiles to use it.']
['It should...']
['function whitelistReferenceModule(address referenceModule, bool whitelist) external']
['This function whitelists a reference module, allowing new publications to use it.']
['It should...']
['function whitelistCollectModule(address collectModule, bool whitelist) external']
['This function whitelists a collect module, allowing new publications to use it.']
['It should...']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['This function returns the collect NFT for the given publication, if any.']
['It should...']
['function getFollowNFTURI(uint256 profileId) external view returns (string memory);']
['Returns']
['This function returns the follow NFT URI for the given profile.']
['It should...']
['function getFollowModule(uint256 profileId) external view returns (address);']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['function createProfile(DataTypes.CreateProfileData calldata vars) external;']
['This function creates a profile.']
['It should...']
['function setFollowModule(uint256 profileId, address followModule, bytes calldata followModuleData) external;']
['This function sets the follow module for the specified profile.']
['It should...']
['Returns']
['This function returns the follow module for the given profile, if any.']
['It should...']
['function getCollectModule(uint256 profileId, uint256 pubId) external view returns (address);']
['Returns']
['This function returns the collect module for the given publication. Note that a publication should not have the zero address as a collect module.']
['It should...']
['function setDispatcher(uint256 profileId, address dispatcher) external;']
["This function sets the dispatcher for a given profile. Note that a profile's dispatcher can publish and set the URI on behalf of the profile above. Dispatchers should be invalidated if the profile NFT is owned by an address other than the one that set the dispatcher."]
['It should...']
['function setProfileImageURI(uint256 profileId, string calldata imageURI) external;']
['This function sets the profile image URI, used to build the on-chain SVG returned on calls to ', 'tokenURI()', ' in the hub.']
['It should...']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['function getReferenceModule(uint256 profileId, uint256 pubId) external view returns (address);']
['Returns']
['This function returns the reference module for the given publication, if any.']
['It should...']
['function getHandle(uint256 profileId) external view returns (string memory);']
['Returns']
['function setFollowNFTURI(uint256 profileId, string calldata followNFTURI) external;']
["This function sets the given profile's follow NFT URI, which is returned on calls to ", 'tokenURI()', ' on the follow NFT. This must return a URI that points to a standardized JSON metadata.']
['It should...']
['function post(DataTypes.PostData calldata vars) external;']
['This function publishes a post to the given profile. ']
['This function returns the handle for the given profile.']
['It should...']
['function getPubPointer(uint256 profileId, uint256 pubId) external view returns (uint256, uint256);']
['Returns']
['This function returns the publication pointer mapped to the given publication, if any. Pointers only exist for mirrors and comments; they indicate the publication being "mirrored" or "commented" on and should never be non-zero for posts.']
['It should...']
['function comment(DataTypes.CommentData calldata vars) external;']
['This function publishes a comment to the given profile. ']
['It should...']
['function commentWithSig(DataTypes.CommentWithSigData calldata vars) external;']
['CommentWithSigData Struct Params:']
['It should...']
['function getContentURI(uint256 profileId, uint256 pubId) external view returns (string memory);']
['Returns']
['This function returns the content URI mapped to the given publication, if any. Note that content URIs only exist for posts and comments and should always be empty for mirrors.']
['It should...']
['function getProfileIdByHandle(string calldata handle) external view returns (uint256);']
['Message Params and Types used for EIP712 signature passed above:']
['This function publishes a comment to the given profile signed by the owner or dispatcher of the profile.']
['It should...']
['function mirror(DataTypes.MirrorData calldata vars) external;']
['This function publishes a mirror to the given profile. ']
['Returns']
['This function returns the profile ID of the profile mapped to a given handle, if any.']
['It should...']
['function getProfile(uint256 profileId) external view returns (DataTypes.ProfileStruct memory);']
['Returns']
['This function returns the profile struct of the profile mapped to a given token ID.']
['It should...']
['function burn(uint256 profileId) external;']
['This function burns a profile NFT. Burned profiles should not be able to be followed.']
['It should...']
['function follow(uint256[] calldata profileIds, bytes[] calldata datas) external;']
["This function follows the given profiles, minting one of each profile's follow NFTs to the follower. Note that there is no issue with following the same profile multiple times."]
['It should...']
['function getPub(uint256 profileId, uint256 pubId) external view returns (DataTypes.PublicationStruct memory);']
['Returns']
['This function returns the publication struct for a given profile ID and publication ID.']
['It should...']
['It should...']
['function collect(uint256 profileId, uint256 pubId, bytes calldata data) external;']
['This function collects the given publication.']
['It should...']
['function getPubType(uint256 profileId, uint256 pubId) external view returns (DataTypes.PubType);']
['Returns']
['This function returns the publication type for a given profile ID and publication ID.']
['It should...']
['function emitFollowNFTTransferEvent(uint256 profileId, uint256 followNFTId, address from, address to) external;']
['This function emits an event when a follow NFT is transferred, to be more easily consumed by clients.']
['It should...']
['function emitCollectNFTTransferEvent(uint256 profileId, uint256 pubId, uint256 collectNFTId, address from, address to) external;']
['Updated', ' ', '11 months ago', ' ']
['full code repo ', 'https://github.com/lens-protocol/lens-api-examples']
['open PR']
['We have a PR to fix this contract side with events once that comes this will be swapped out for the contract change which will be supported in the API as well.']
['This function emits an event when a follow NFT is transferred, to be more easily consumed by clients.']
['It should...']
['Updated', ' ', 'about 2 months ago', ' ']
['This request is protected by authentication']
['hint: this means it requires an x-access-token header put in the request with your authentication token.']
['To get around the issues with people being able to spam other people with a follower NFT we have brought in approval follows server-side logic. ']
['Look at this situation:']
['You can see from the above how this could be a huge issue and with spam already a major thing on cheap transaction chains we do see this being a problem from day 1. ']
['To solve this for now we have a server approach but we have an open PR to allow this to be traceable onchain with events which we hope to merge soon. ']
['The approach we are taking to solve this is:']
['This mutation approves the follow and now on the API side, it looks like you follow this profile from your wallet.']
['returns a ', 'VoidScalar', ' which means no response is returned if you do look at the response data it will be data.approveFollow = null but you do not need to look at the response for anything which returns ', 'void', '. If it does not throw it is successful. ']
['Updated', ' ', '5 months ago', ' ']
['View functions in the LensHub.sol contract']
['You can only suggest edits to Markdown body content, but not to the API spec.']
['State changing functions in the LensHub.sol contract']
['You can only suggest edits to Markdown body content, but not to the API spec.']
